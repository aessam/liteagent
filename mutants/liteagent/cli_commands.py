"""
Command-line interface functionality for LiteAgent.
Contains the core CLI functions.
"""

import sys
import os
import argparse
import json
from dotenv import load_dotenv
from .utils import setup_logging, logger
from .observer import ConsoleObserver, FileObserver, TreeTraceObserver
from .tools import get_function_definitions, FunctionTool, InstanceMethodTool, liteagent_tool
from typing import List, Dict, Any
from inspect import signature as _mutmut_signature
from typing import Annotated
from typing import Callable
from typing import ClassVar


MutantDict = Annotated[dict[str, Callable], "Mutant"]


def _mutmut_trampoline(orig, mutants, call_args, call_kwargs, self_arg = None):
    """Forward call to original or mutated function, depending on the environment"""
    import os
    mutant_under_test = os.environ['MUTANT_UNDER_TEST']
    if mutant_under_test == 'fail':
        from mutmut.__main__ import MutmutProgrammaticFailException
        raise MutmutProgrammaticFailException('Failed programmatically')      
    elif mutant_under_test == 'stats':
        from mutmut.__main__ import record_trampoline_hit
        record_trampoline_hit(orig.__module__ + '.' + orig.__name__)
        result = orig(*call_args, **call_kwargs)
        return result
    prefix = orig.__module__ + '.' + orig.__name__ + '__mutmut_'
    if not mutant_under_test.startswith(prefix):
        result = orig(*call_args, **call_kwargs)
        return result
    mutant_name = mutant_under_test.rpartition('.')[-1]
    if self_arg:
        # call to a class method where self is not bound
        result = mutants[mutant_name](self_arg, *call_args, **call_kwargs)
    else:
        result = mutants[mutant_name](*call_args, **call_kwargs)
    return result

def x_parse_arguments__mutmut_orig():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_1():
    """Parse command line arguments."""
    parser = None
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_2():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description=None,
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_3():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=None
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_4():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_5():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_6():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="XXLiteAgent - A lightweight agent framework for LLM interactionsXX",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_7():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="liteagent - a lightweight agent framework for llm interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_8():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LITEAGENT - A LIGHTWEIGHT AGENT FRAMEWORK FOR LLM INTERACTIONS",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_9():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = None
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_10():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest=None, help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_11():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help=None)
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_12():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_13():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', )
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_14():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='XXcommandXX', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_15():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='COMMAND', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_16():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='XXCommand to runXX')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_17():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_18():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='COMMAND TO RUN')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_19():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = None
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_20():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser(None, help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_21():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help=None)
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_22():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser(help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_23():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', )
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_24():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('XXrunXX', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_25():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('RUN', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_26():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='XXRun examplesXX')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_27():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_28():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='RUN EXAMPLES')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_29():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = None
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_30():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument(None, action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_31():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action=None,
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_32():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help=None)
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_33():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument(action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_34():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_35():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      )
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_36():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("XX--class-methodsXX", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_37():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--CLASS-METHODS", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_38():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="XXstore_trueXX",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_39():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="STORE_TRUE",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_40():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="XXRun only the class methods exampleXX")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_41():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_42():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="RUN ONLY THE CLASS METHODS EXAMPLE")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_43():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument(None, action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_44():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action=None,
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_45():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help=None)
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_46():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument(action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_47():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_48():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      )
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_49():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("XX--custom-agentsXX", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_50():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--CUSTOM-AGENTS", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_51():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="XXstore_trueXX",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_52():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="STORE_TRUE",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_53():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="XXRun only the custom agents exampleXX")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_54():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_55():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="RUN ONLY THE CUSTOM AGENTS EXAMPLE")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_56():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument(None, action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_57():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action=None,
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_58():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help=None)
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_59():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument(action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_60():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_61():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      )
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_62():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("XX--allXX", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_63():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--ALL", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_64():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="XXstore_trueXX",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_65():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="STORE_TRUE",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_66():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="XXRun all examples (this is the default behavior)XX")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_67():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_68():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="RUN ALL EXAMPLES (THIS IS THE DEFAULT BEHAVIOR)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_69():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument(None, type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_70():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=None, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_71():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default=None,
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_72():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help=None)
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_73():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument(type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_74():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_75():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_76():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        )
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_77():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("XX--modelXX", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_78():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--MODEL", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_79():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="XXgpt-4o-miniXX",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_80():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="GPT-4O-MINI",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_81():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="XXModel to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)XX")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_82():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_83():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="MODEL TO USE FOR THE AGENT (E.G., GPT-3.5-TURBO, GPT-4O-MINI, OLLAMA/PHI4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_84():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument(None, action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_85():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action=None,
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_86():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help=None)
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_87():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument(action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_88():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_89():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        )
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_90():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("XX--ollamaXX", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_91():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--OLLAMA", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_92():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="XXstore_trueXX",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_93():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="STORE_TRUE",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_94():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="XXUse Ollama for local inference (automatically prepends 'ollama/' to model name if needed)XX")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_95():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="use ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_96():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="USE OLLAMA FOR LOCAL INFERENCE (AUTOMATICALLY PREPENDS 'OLLAMA/' TO MODEL NAME IF NEEDED)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_97():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument(None, action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_98():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action=None,
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_99():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help=None)
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_100():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument(action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_101():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_102():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       )
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_103():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("XX--enable-observabilityXX", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_104():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--ENABLE-OBSERVABILITY", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_105():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="XXstore_trueXX",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_106():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="STORE_TRUE",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_107():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="XXEnable observability features (console, file, and tree trace observers)XX")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_108():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_109():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="ENABLE OBSERVABILITY FEATURES (CONSOLE, FILE, AND TREE TRACE OBSERVERS)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_110():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = None
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_111():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser(None, help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_112():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help=None)
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_113():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser(help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_114():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', )
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_115():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('XXtoolsXX', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_116():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('TOOLS', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_117():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='XXTool operationsXX')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_118():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_119():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='TOOL OPERATIONS')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_120():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument(None, "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_121():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", None, action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_122():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action=None,
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_123():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help=None)
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_124():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_125():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_126():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_127():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       )
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_128():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("XX--sample-outputXX", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_129():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--SAMPLE-OUTPUT", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_130():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "XX-soXX", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_131():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-SO", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_132():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="XXstore_trueXX",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_133():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="STORE_TRUE",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_134():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="XXPrint a sample of tool definitions as they would be sent to the LLMXX")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_135():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="print a sample of tool definitions as they would be sent to the llm")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_136():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="PRINT A SAMPLE OF TOOL DEFINITIONS AS THEY WOULD BE SENT TO THE LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_137():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument(None, action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_138():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action=None,
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_139():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help=None)
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_140():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument(action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_141():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_142():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       )
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_143():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("XX--versionXX", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_144():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--VERSION", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_145():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="XXstore_trueXX",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_146():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="STORE_TRUE",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_147():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="XXShow version information and exitXX")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_148():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_149():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="SHOW VERSION INFORMATION AND EXIT")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_150():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = None
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_151():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group(None)
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_152():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("XXDebugging optionsXX")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_153():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_154():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("DEBUGGING OPTIONS")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_155():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument(None, action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_156():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action=None,
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_157():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help=None)
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_158():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument(action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_159():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_160():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       )
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_161():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("XX--debugXX", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_162():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--DEBUG", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_163():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="XXstore_trueXX",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_164():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="STORE_TRUE",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_165():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="XXEnable debug mode with verbose loggingXX")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_166():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_167():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="ENABLE DEBUG MODE WITH VERBOSE LOGGING")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_168():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument(None, action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_169():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action=None,
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_170():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help=None)
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_171():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument(action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_172():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_173():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       )
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_174():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("XX--log-fileXX", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_175():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--LOG-FILE", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_176():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="XXstore_trueXX",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_177():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="STORE_TRUE",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_178():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="XXLog output to a file in addition to consoleXX")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_179():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_180():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="LOG OUTPUT TO A FILE IN ADDITION TO CONSOLE")
    debug_group.add_argument("--no-color", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_181():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument(None, action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_182():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action=None,
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_183():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help=None)
    
    return parser.parse_args()

def x_parse_arguments__mutmut_184():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument(action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_185():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_186():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       )
    
    return parser.parse_args()

def x_parse_arguments__mutmut_187():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("XX--no-colorXX", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_188():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--NO-COLOR", action="store_true",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_189():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="XXstore_trueXX",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_190():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="STORE_TRUE",
                       help="Disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_191():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="XXDisable colored log outputXX")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_192():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="disable colored log output")
    
    return parser.parse_args()

def x_parse_arguments__mutmut_193():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="LiteAgent - A lightweight agent framework for LLM interactions",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # 'run' command for running examples
    run_parser = subparsers.add_parser('run', help='Run examples')
    
    # Example selection for run command
    run_group = run_parser.add_mutually_exclusive_group()
    run_group.add_argument("--class-methods", action="store_true",
                      help="Run only the class methods example")
    run_group.add_argument("--custom-agents", action="store_true",
                      help="Run only the custom agents example")
    run_group.add_argument("--all", action="store_true",
                      help="Run all examples (this is the default behavior)")
    
    # Model selection for run command
    run_parser.add_argument("--model", type=str, default="gpt-4o-mini",
                        help="Model to use for the agent (e.g., gpt-3.5-turbo, gpt-4o-mini, ollama/phi4)")
    
    # Ollama helper for run command
    run_parser.add_argument("--ollama", action="store_true",
                        help="Use Ollama for local inference (automatically prepends 'ollama/' to model name if needed)")
    
    # Observability options for run command
    run_parser.add_argument("--enable-observability", action="store_true",
                       help="Enable observability features (console, file, and tree trace observers)")
    
    # 'tools' command for tool operations
    tools_parser = subparsers.add_parser('tools', help='Tool operations')
    tools_parser.add_argument("--sample-output", "-so", action="store_true",
                       help="Print a sample of tool definitions as they would be sent to the LLM")
    
    # Global options that apply to all commands
    parser.add_argument("--version", action="store_true",
                       help="Show version information and exit")
    
    # Debug options (global)
    debug_group = parser.add_argument_group("Debugging options")
    debug_group.add_argument("--debug", action="store_true",
                       help="Enable debug mode with verbose logging")
    debug_group.add_argument("--log-file", action="store_true",
                       help="Log output to a file in addition to console")
    debug_group.add_argument("--no-color", action="store_true",
                       help="DISABLE COLORED LOG OUTPUT")
    
    return parser.parse_args()

x_parse_arguments__mutmut_mutants : ClassVar[MutantDict] = {
'x_parse_arguments__mutmut_1': x_parse_arguments__mutmut_1, 
    'x_parse_arguments__mutmut_2': x_parse_arguments__mutmut_2, 
    'x_parse_arguments__mutmut_3': x_parse_arguments__mutmut_3, 
    'x_parse_arguments__mutmut_4': x_parse_arguments__mutmut_4, 
    'x_parse_arguments__mutmut_5': x_parse_arguments__mutmut_5, 
    'x_parse_arguments__mutmut_6': x_parse_arguments__mutmut_6, 
    'x_parse_arguments__mutmut_7': x_parse_arguments__mutmut_7, 
    'x_parse_arguments__mutmut_8': x_parse_arguments__mutmut_8, 
    'x_parse_arguments__mutmut_9': x_parse_arguments__mutmut_9, 
    'x_parse_arguments__mutmut_10': x_parse_arguments__mutmut_10, 
    'x_parse_arguments__mutmut_11': x_parse_arguments__mutmut_11, 
    'x_parse_arguments__mutmut_12': x_parse_arguments__mutmut_12, 
    'x_parse_arguments__mutmut_13': x_parse_arguments__mutmut_13, 
    'x_parse_arguments__mutmut_14': x_parse_arguments__mutmut_14, 
    'x_parse_arguments__mutmut_15': x_parse_arguments__mutmut_15, 
    'x_parse_arguments__mutmut_16': x_parse_arguments__mutmut_16, 
    'x_parse_arguments__mutmut_17': x_parse_arguments__mutmut_17, 
    'x_parse_arguments__mutmut_18': x_parse_arguments__mutmut_18, 
    'x_parse_arguments__mutmut_19': x_parse_arguments__mutmut_19, 
    'x_parse_arguments__mutmut_20': x_parse_arguments__mutmut_20, 
    'x_parse_arguments__mutmut_21': x_parse_arguments__mutmut_21, 
    'x_parse_arguments__mutmut_22': x_parse_arguments__mutmut_22, 
    'x_parse_arguments__mutmut_23': x_parse_arguments__mutmut_23, 
    'x_parse_arguments__mutmut_24': x_parse_arguments__mutmut_24, 
    'x_parse_arguments__mutmut_25': x_parse_arguments__mutmut_25, 
    'x_parse_arguments__mutmut_26': x_parse_arguments__mutmut_26, 
    'x_parse_arguments__mutmut_27': x_parse_arguments__mutmut_27, 
    'x_parse_arguments__mutmut_28': x_parse_arguments__mutmut_28, 
    'x_parse_arguments__mutmut_29': x_parse_arguments__mutmut_29, 
    'x_parse_arguments__mutmut_30': x_parse_arguments__mutmut_30, 
    'x_parse_arguments__mutmut_31': x_parse_arguments__mutmut_31, 
    'x_parse_arguments__mutmut_32': x_parse_arguments__mutmut_32, 
    'x_parse_arguments__mutmut_33': x_parse_arguments__mutmut_33, 
    'x_parse_arguments__mutmut_34': x_parse_arguments__mutmut_34, 
    'x_parse_arguments__mutmut_35': x_parse_arguments__mutmut_35, 
    'x_parse_arguments__mutmut_36': x_parse_arguments__mutmut_36, 
    'x_parse_arguments__mutmut_37': x_parse_arguments__mutmut_37, 
    'x_parse_arguments__mutmut_38': x_parse_arguments__mutmut_38, 
    'x_parse_arguments__mutmut_39': x_parse_arguments__mutmut_39, 
    'x_parse_arguments__mutmut_40': x_parse_arguments__mutmut_40, 
    'x_parse_arguments__mutmut_41': x_parse_arguments__mutmut_41, 
    'x_parse_arguments__mutmut_42': x_parse_arguments__mutmut_42, 
    'x_parse_arguments__mutmut_43': x_parse_arguments__mutmut_43, 
    'x_parse_arguments__mutmut_44': x_parse_arguments__mutmut_44, 
    'x_parse_arguments__mutmut_45': x_parse_arguments__mutmut_45, 
    'x_parse_arguments__mutmut_46': x_parse_arguments__mutmut_46, 
    'x_parse_arguments__mutmut_47': x_parse_arguments__mutmut_47, 
    'x_parse_arguments__mutmut_48': x_parse_arguments__mutmut_48, 
    'x_parse_arguments__mutmut_49': x_parse_arguments__mutmut_49, 
    'x_parse_arguments__mutmut_50': x_parse_arguments__mutmut_50, 
    'x_parse_arguments__mutmut_51': x_parse_arguments__mutmut_51, 
    'x_parse_arguments__mutmut_52': x_parse_arguments__mutmut_52, 
    'x_parse_arguments__mutmut_53': x_parse_arguments__mutmut_53, 
    'x_parse_arguments__mutmut_54': x_parse_arguments__mutmut_54, 
    'x_parse_arguments__mutmut_55': x_parse_arguments__mutmut_55, 
    'x_parse_arguments__mutmut_56': x_parse_arguments__mutmut_56, 
    'x_parse_arguments__mutmut_57': x_parse_arguments__mutmut_57, 
    'x_parse_arguments__mutmut_58': x_parse_arguments__mutmut_58, 
    'x_parse_arguments__mutmut_59': x_parse_arguments__mutmut_59, 
    'x_parse_arguments__mutmut_60': x_parse_arguments__mutmut_60, 
    'x_parse_arguments__mutmut_61': x_parse_arguments__mutmut_61, 
    'x_parse_arguments__mutmut_62': x_parse_arguments__mutmut_62, 
    'x_parse_arguments__mutmut_63': x_parse_arguments__mutmut_63, 
    'x_parse_arguments__mutmut_64': x_parse_arguments__mutmut_64, 
    'x_parse_arguments__mutmut_65': x_parse_arguments__mutmut_65, 
    'x_parse_arguments__mutmut_66': x_parse_arguments__mutmut_66, 
    'x_parse_arguments__mutmut_67': x_parse_arguments__mutmut_67, 
    'x_parse_arguments__mutmut_68': x_parse_arguments__mutmut_68, 
    'x_parse_arguments__mutmut_69': x_parse_arguments__mutmut_69, 
    'x_parse_arguments__mutmut_70': x_parse_arguments__mutmut_70, 
    'x_parse_arguments__mutmut_71': x_parse_arguments__mutmut_71, 
    'x_parse_arguments__mutmut_72': x_parse_arguments__mutmut_72, 
    'x_parse_arguments__mutmut_73': x_parse_arguments__mutmut_73, 
    'x_parse_arguments__mutmut_74': x_parse_arguments__mutmut_74, 
    'x_parse_arguments__mutmut_75': x_parse_arguments__mutmut_75, 
    'x_parse_arguments__mutmut_76': x_parse_arguments__mutmut_76, 
    'x_parse_arguments__mutmut_77': x_parse_arguments__mutmut_77, 
    'x_parse_arguments__mutmut_78': x_parse_arguments__mutmut_78, 
    'x_parse_arguments__mutmut_79': x_parse_arguments__mutmut_79, 
    'x_parse_arguments__mutmut_80': x_parse_arguments__mutmut_80, 
    'x_parse_arguments__mutmut_81': x_parse_arguments__mutmut_81, 
    'x_parse_arguments__mutmut_82': x_parse_arguments__mutmut_82, 
    'x_parse_arguments__mutmut_83': x_parse_arguments__mutmut_83, 
    'x_parse_arguments__mutmut_84': x_parse_arguments__mutmut_84, 
    'x_parse_arguments__mutmut_85': x_parse_arguments__mutmut_85, 
    'x_parse_arguments__mutmut_86': x_parse_arguments__mutmut_86, 
    'x_parse_arguments__mutmut_87': x_parse_arguments__mutmut_87, 
    'x_parse_arguments__mutmut_88': x_parse_arguments__mutmut_88, 
    'x_parse_arguments__mutmut_89': x_parse_arguments__mutmut_89, 
    'x_parse_arguments__mutmut_90': x_parse_arguments__mutmut_90, 
    'x_parse_arguments__mutmut_91': x_parse_arguments__mutmut_91, 
    'x_parse_arguments__mutmut_92': x_parse_arguments__mutmut_92, 
    'x_parse_arguments__mutmut_93': x_parse_arguments__mutmut_93, 
    'x_parse_arguments__mutmut_94': x_parse_arguments__mutmut_94, 
    'x_parse_arguments__mutmut_95': x_parse_arguments__mutmut_95, 
    'x_parse_arguments__mutmut_96': x_parse_arguments__mutmut_96, 
    'x_parse_arguments__mutmut_97': x_parse_arguments__mutmut_97, 
    'x_parse_arguments__mutmut_98': x_parse_arguments__mutmut_98, 
    'x_parse_arguments__mutmut_99': x_parse_arguments__mutmut_99, 
    'x_parse_arguments__mutmut_100': x_parse_arguments__mutmut_100, 
    'x_parse_arguments__mutmut_101': x_parse_arguments__mutmut_101, 
    'x_parse_arguments__mutmut_102': x_parse_arguments__mutmut_102, 
    'x_parse_arguments__mutmut_103': x_parse_arguments__mutmut_103, 
    'x_parse_arguments__mutmut_104': x_parse_arguments__mutmut_104, 
    'x_parse_arguments__mutmut_105': x_parse_arguments__mutmut_105, 
    'x_parse_arguments__mutmut_106': x_parse_arguments__mutmut_106, 
    'x_parse_arguments__mutmut_107': x_parse_arguments__mutmut_107, 
    'x_parse_arguments__mutmut_108': x_parse_arguments__mutmut_108, 
    'x_parse_arguments__mutmut_109': x_parse_arguments__mutmut_109, 
    'x_parse_arguments__mutmut_110': x_parse_arguments__mutmut_110, 
    'x_parse_arguments__mutmut_111': x_parse_arguments__mutmut_111, 
    'x_parse_arguments__mutmut_112': x_parse_arguments__mutmut_112, 
    'x_parse_arguments__mutmut_113': x_parse_arguments__mutmut_113, 
    'x_parse_arguments__mutmut_114': x_parse_arguments__mutmut_114, 
    'x_parse_arguments__mutmut_115': x_parse_arguments__mutmut_115, 
    'x_parse_arguments__mutmut_116': x_parse_arguments__mutmut_116, 
    'x_parse_arguments__mutmut_117': x_parse_arguments__mutmut_117, 
    'x_parse_arguments__mutmut_118': x_parse_arguments__mutmut_118, 
    'x_parse_arguments__mutmut_119': x_parse_arguments__mutmut_119, 
    'x_parse_arguments__mutmut_120': x_parse_arguments__mutmut_120, 
    'x_parse_arguments__mutmut_121': x_parse_arguments__mutmut_121, 
    'x_parse_arguments__mutmut_122': x_parse_arguments__mutmut_122, 
    'x_parse_arguments__mutmut_123': x_parse_arguments__mutmut_123, 
    'x_parse_arguments__mutmut_124': x_parse_arguments__mutmut_124, 
    'x_parse_arguments__mutmut_125': x_parse_arguments__mutmut_125, 
    'x_parse_arguments__mutmut_126': x_parse_arguments__mutmut_126, 
    'x_parse_arguments__mutmut_127': x_parse_arguments__mutmut_127, 
    'x_parse_arguments__mutmut_128': x_parse_arguments__mutmut_128, 
    'x_parse_arguments__mutmut_129': x_parse_arguments__mutmut_129, 
    'x_parse_arguments__mutmut_130': x_parse_arguments__mutmut_130, 
    'x_parse_arguments__mutmut_131': x_parse_arguments__mutmut_131, 
    'x_parse_arguments__mutmut_132': x_parse_arguments__mutmut_132, 
    'x_parse_arguments__mutmut_133': x_parse_arguments__mutmut_133, 
    'x_parse_arguments__mutmut_134': x_parse_arguments__mutmut_134, 
    'x_parse_arguments__mutmut_135': x_parse_arguments__mutmut_135, 
    'x_parse_arguments__mutmut_136': x_parse_arguments__mutmut_136, 
    'x_parse_arguments__mutmut_137': x_parse_arguments__mutmut_137, 
    'x_parse_arguments__mutmut_138': x_parse_arguments__mutmut_138, 
    'x_parse_arguments__mutmut_139': x_parse_arguments__mutmut_139, 
    'x_parse_arguments__mutmut_140': x_parse_arguments__mutmut_140, 
    'x_parse_arguments__mutmut_141': x_parse_arguments__mutmut_141, 
    'x_parse_arguments__mutmut_142': x_parse_arguments__mutmut_142, 
    'x_parse_arguments__mutmut_143': x_parse_arguments__mutmut_143, 
    'x_parse_arguments__mutmut_144': x_parse_arguments__mutmut_144, 
    'x_parse_arguments__mutmut_145': x_parse_arguments__mutmut_145, 
    'x_parse_arguments__mutmut_146': x_parse_arguments__mutmut_146, 
    'x_parse_arguments__mutmut_147': x_parse_arguments__mutmut_147, 
    'x_parse_arguments__mutmut_148': x_parse_arguments__mutmut_148, 
    'x_parse_arguments__mutmut_149': x_parse_arguments__mutmut_149, 
    'x_parse_arguments__mutmut_150': x_parse_arguments__mutmut_150, 
    'x_parse_arguments__mutmut_151': x_parse_arguments__mutmut_151, 
    'x_parse_arguments__mutmut_152': x_parse_arguments__mutmut_152, 
    'x_parse_arguments__mutmut_153': x_parse_arguments__mutmut_153, 
    'x_parse_arguments__mutmut_154': x_parse_arguments__mutmut_154, 
    'x_parse_arguments__mutmut_155': x_parse_arguments__mutmut_155, 
    'x_parse_arguments__mutmut_156': x_parse_arguments__mutmut_156, 
    'x_parse_arguments__mutmut_157': x_parse_arguments__mutmut_157, 
    'x_parse_arguments__mutmut_158': x_parse_arguments__mutmut_158, 
    'x_parse_arguments__mutmut_159': x_parse_arguments__mutmut_159, 
    'x_parse_arguments__mutmut_160': x_parse_arguments__mutmut_160, 
    'x_parse_arguments__mutmut_161': x_parse_arguments__mutmut_161, 
    'x_parse_arguments__mutmut_162': x_parse_arguments__mutmut_162, 
    'x_parse_arguments__mutmut_163': x_parse_arguments__mutmut_163, 
    'x_parse_arguments__mutmut_164': x_parse_arguments__mutmut_164, 
    'x_parse_arguments__mutmut_165': x_parse_arguments__mutmut_165, 
    'x_parse_arguments__mutmut_166': x_parse_arguments__mutmut_166, 
    'x_parse_arguments__mutmut_167': x_parse_arguments__mutmut_167, 
    'x_parse_arguments__mutmut_168': x_parse_arguments__mutmut_168, 
    'x_parse_arguments__mutmut_169': x_parse_arguments__mutmut_169, 
    'x_parse_arguments__mutmut_170': x_parse_arguments__mutmut_170, 
    'x_parse_arguments__mutmut_171': x_parse_arguments__mutmut_171, 
    'x_parse_arguments__mutmut_172': x_parse_arguments__mutmut_172, 
    'x_parse_arguments__mutmut_173': x_parse_arguments__mutmut_173, 
    'x_parse_arguments__mutmut_174': x_parse_arguments__mutmut_174, 
    'x_parse_arguments__mutmut_175': x_parse_arguments__mutmut_175, 
    'x_parse_arguments__mutmut_176': x_parse_arguments__mutmut_176, 
    'x_parse_arguments__mutmut_177': x_parse_arguments__mutmut_177, 
    'x_parse_arguments__mutmut_178': x_parse_arguments__mutmut_178, 
    'x_parse_arguments__mutmut_179': x_parse_arguments__mutmut_179, 
    'x_parse_arguments__mutmut_180': x_parse_arguments__mutmut_180, 
    'x_parse_arguments__mutmut_181': x_parse_arguments__mutmut_181, 
    'x_parse_arguments__mutmut_182': x_parse_arguments__mutmut_182, 
    'x_parse_arguments__mutmut_183': x_parse_arguments__mutmut_183, 
    'x_parse_arguments__mutmut_184': x_parse_arguments__mutmut_184, 
    'x_parse_arguments__mutmut_185': x_parse_arguments__mutmut_185, 
    'x_parse_arguments__mutmut_186': x_parse_arguments__mutmut_186, 
    'x_parse_arguments__mutmut_187': x_parse_arguments__mutmut_187, 
    'x_parse_arguments__mutmut_188': x_parse_arguments__mutmut_188, 
    'x_parse_arguments__mutmut_189': x_parse_arguments__mutmut_189, 
    'x_parse_arguments__mutmut_190': x_parse_arguments__mutmut_190, 
    'x_parse_arguments__mutmut_191': x_parse_arguments__mutmut_191, 
    'x_parse_arguments__mutmut_192': x_parse_arguments__mutmut_192, 
    'x_parse_arguments__mutmut_193': x_parse_arguments__mutmut_193
}

def parse_arguments(*args, **kwargs):
    result = _mutmut_trampoline(x_parse_arguments__mutmut_orig, x_parse_arguments__mutmut_mutants, args, kwargs)
    return result 

parse_arguments.__signature__ = _mutmut_signature(x_parse_arguments__mutmut_orig)
x_parse_arguments__mutmut_orig.__name__ = 'x_parse_arguments'

def x_show_version__mutmut_orig():
    """Display version information."""
    # Try to import from relative path first (for package imports)
    try:
        from liteagent import __version__
        print(f"LiteAgent version: {__version__}")
    except (ImportError, ValueError):
        # Try direct import for when called from main.py
        try:
            from liteagent import __version__
            print(f"LiteAgent version: {__version__}")
        except ImportError:
            print("LiteAgent version: unknown")
    
    print("Using official provider client libraries for model interactions")
    
    sys.exit(0)

def x_show_version__mutmut_1():
    """Display version information."""
    # Try to import from relative path first (for package imports)
    try:
        from liteagent import __version__
        print(None)
    except (ImportError, ValueError):
        # Try direct import for when called from main.py
        try:
            from liteagent import __version__
            print(f"LiteAgent version: {__version__}")
        except ImportError:
            print("LiteAgent version: unknown")
    
    print("Using official provider client libraries for model interactions")
    
    sys.exit(0)

def x_show_version__mutmut_2():
    """Display version information."""
    # Try to import from relative path first (for package imports)
    try:
        from liteagent import __version__
        print(f"LiteAgent version: {__version__}")
    except (ImportError, ValueError):
        # Try direct import for when called from main.py
        try:
            from liteagent import __version__
            print(None)
        except ImportError:
            print("LiteAgent version: unknown")
    
    print("Using official provider client libraries for model interactions")
    
    sys.exit(0)

def x_show_version__mutmut_3():
    """Display version information."""
    # Try to import from relative path first (for package imports)
    try:
        from liteagent import __version__
        print(f"LiteAgent version: {__version__}")
    except (ImportError, ValueError):
        # Try direct import for when called from main.py
        try:
            from liteagent import __version__
            print(f"LiteAgent version: {__version__}")
        except ImportError:
            print(None)
    
    print("Using official provider client libraries for model interactions")
    
    sys.exit(0)

def x_show_version__mutmut_4():
    """Display version information."""
    # Try to import from relative path first (for package imports)
    try:
        from liteagent import __version__
        print(f"LiteAgent version: {__version__}")
    except (ImportError, ValueError):
        # Try direct import for when called from main.py
        try:
            from liteagent import __version__
            print(f"LiteAgent version: {__version__}")
        except ImportError:
            print("XXLiteAgent version: unknownXX")
    
    print("Using official provider client libraries for model interactions")
    
    sys.exit(0)

def x_show_version__mutmut_5():
    """Display version information."""
    # Try to import from relative path first (for package imports)
    try:
        from liteagent import __version__
        print(f"LiteAgent version: {__version__}")
    except (ImportError, ValueError):
        # Try direct import for when called from main.py
        try:
            from liteagent import __version__
            print(f"LiteAgent version: {__version__}")
        except ImportError:
            print("liteagent version: unknown")
    
    print("Using official provider client libraries for model interactions")
    
    sys.exit(0)

def x_show_version__mutmut_6():
    """Display version information."""
    # Try to import from relative path first (for package imports)
    try:
        from liteagent import __version__
        print(f"LiteAgent version: {__version__}")
    except (ImportError, ValueError):
        # Try direct import for when called from main.py
        try:
            from liteagent import __version__
            print(f"LiteAgent version: {__version__}")
        except ImportError:
            print("LITEAGENT VERSION: UNKNOWN")
    
    print("Using official provider client libraries for model interactions")
    
    sys.exit(0)

def x_show_version__mutmut_7():
    """Display version information."""
    # Try to import from relative path first (for package imports)
    try:
        from liteagent import __version__
        print(f"LiteAgent version: {__version__}")
    except (ImportError, ValueError):
        # Try direct import for when called from main.py
        try:
            from liteagent import __version__
            print(f"LiteAgent version: {__version__}")
        except ImportError:
            print("LiteAgent version: unknown")
    
    print(None)
    
    sys.exit(0)

def x_show_version__mutmut_8():
    """Display version information."""
    # Try to import from relative path first (for package imports)
    try:
        from liteagent import __version__
        print(f"LiteAgent version: {__version__}")
    except (ImportError, ValueError):
        # Try direct import for when called from main.py
        try:
            from liteagent import __version__
            print(f"LiteAgent version: {__version__}")
        except ImportError:
            print("LiteAgent version: unknown")
    
    print("XXUsing official provider client libraries for model interactionsXX")
    
    sys.exit(0)

def x_show_version__mutmut_9():
    """Display version information."""
    # Try to import from relative path first (for package imports)
    try:
        from liteagent import __version__
        print(f"LiteAgent version: {__version__}")
    except (ImportError, ValueError):
        # Try direct import for when called from main.py
        try:
            from liteagent import __version__
            print(f"LiteAgent version: {__version__}")
        except ImportError:
            print("LiteAgent version: unknown")
    
    print("using official provider client libraries for model interactions")
    
    sys.exit(0)

def x_show_version__mutmut_10():
    """Display version information."""
    # Try to import from relative path first (for package imports)
    try:
        from liteagent import __version__
        print(f"LiteAgent version: {__version__}")
    except (ImportError, ValueError):
        # Try direct import for when called from main.py
        try:
            from liteagent import __version__
            print(f"LiteAgent version: {__version__}")
        except ImportError:
            print("LiteAgent version: unknown")
    
    print("USING OFFICIAL PROVIDER CLIENT LIBRARIES FOR MODEL INTERACTIONS")
    
    sys.exit(0)

def x_show_version__mutmut_11():
    """Display version information."""
    # Try to import from relative path first (for package imports)
    try:
        from liteagent import __version__
        print(f"LiteAgent version: {__version__}")
    except (ImportError, ValueError):
        # Try direct import for when called from main.py
        try:
            from liteagent import __version__
            print(f"LiteAgent version: {__version__}")
        except ImportError:
            print("LiteAgent version: unknown")
    
    print("Using official provider client libraries for model interactions")
    
    sys.exit(None)

def x_show_version__mutmut_12():
    """Display version information."""
    # Try to import from relative path first (for package imports)
    try:
        from liteagent import __version__
        print(f"LiteAgent version: {__version__}")
    except (ImportError, ValueError):
        # Try direct import for when called from main.py
        try:
            from liteagent import __version__
            print(f"LiteAgent version: {__version__}")
        except ImportError:
            print("LiteAgent version: unknown")
    
    print("Using official provider client libraries for model interactions")
    
    sys.exit(1)

x_show_version__mutmut_mutants : ClassVar[MutantDict] = {
'x_show_version__mutmut_1': x_show_version__mutmut_1, 
    'x_show_version__mutmut_2': x_show_version__mutmut_2, 
    'x_show_version__mutmut_3': x_show_version__mutmut_3, 
    'x_show_version__mutmut_4': x_show_version__mutmut_4, 
    'x_show_version__mutmut_5': x_show_version__mutmut_5, 
    'x_show_version__mutmut_6': x_show_version__mutmut_6, 
    'x_show_version__mutmut_7': x_show_version__mutmut_7, 
    'x_show_version__mutmut_8': x_show_version__mutmut_8, 
    'x_show_version__mutmut_9': x_show_version__mutmut_9, 
    'x_show_version__mutmut_10': x_show_version__mutmut_10, 
    'x_show_version__mutmut_11': x_show_version__mutmut_11, 
    'x_show_version__mutmut_12': x_show_version__mutmut_12
}

def show_version(*args, **kwargs):
    result = _mutmut_trampoline(x_show_version__mutmut_orig, x_show_version__mutmut_mutants, args, kwargs)
    return result 

show_version.__signature__ = _mutmut_signature(x_show_version__mutmut_orig)
x_show_version__mutmut_orig.__name__ = 'x_show_version'

def x_run_examples__mutmut_orig(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("Enabling observability features")
        observers.append(ConsoleObserver())
        observers.append(FileObserver('agent_events.jsonl'))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("Running class methods example")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, observers=observers)
    elif args.custom_agents:
        logger.info("Running custom agents example")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, observers=observers)
    else:  # Default or --all
        logger.info("Running all examples")
        from examples.basic_examples import run_examples
        run_examples(model=args.model, observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_1(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = None
    if args.enable_observability:
        logger.info("Enabling observability features")
        observers.append(ConsoleObserver())
        observers.append(FileObserver('agent_events.jsonl'))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("Running class methods example")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, observers=observers)
    elif args.custom_agents:
        logger.info("Running custom agents example")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, observers=observers)
    else:  # Default or --all
        logger.info("Running all examples")
        from examples.basic_examples import run_examples
        run_examples(model=args.model, observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_2(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info(None)
        observers.append(ConsoleObserver())
        observers.append(FileObserver('agent_events.jsonl'))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("Running class methods example")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, observers=observers)
    elif args.custom_agents:
        logger.info("Running custom agents example")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, observers=observers)
    else:  # Default or --all
        logger.info("Running all examples")
        from examples.basic_examples import run_examples
        run_examples(model=args.model, observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_3(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("XXEnabling observability featuresXX")
        observers.append(ConsoleObserver())
        observers.append(FileObserver('agent_events.jsonl'))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("Running class methods example")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, observers=observers)
    elif args.custom_agents:
        logger.info("Running custom agents example")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, observers=observers)
    else:  # Default or --all
        logger.info("Running all examples")
        from examples.basic_examples import run_examples
        run_examples(model=args.model, observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_4(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("enabling observability features")
        observers.append(ConsoleObserver())
        observers.append(FileObserver('agent_events.jsonl'))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("Running class methods example")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, observers=observers)
    elif args.custom_agents:
        logger.info("Running custom agents example")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, observers=observers)
    else:  # Default or --all
        logger.info("Running all examples")
        from examples.basic_examples import run_examples
        run_examples(model=args.model, observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_5(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("ENABLING OBSERVABILITY FEATURES")
        observers.append(ConsoleObserver())
        observers.append(FileObserver('agent_events.jsonl'))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("Running class methods example")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, observers=observers)
    elif args.custom_agents:
        logger.info("Running custom agents example")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, observers=observers)
    else:  # Default or --all
        logger.info("Running all examples")
        from examples.basic_examples import run_examples
        run_examples(model=args.model, observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_6(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("Enabling observability features")
        observers.append(None)
        observers.append(FileObserver('agent_events.jsonl'))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("Running class methods example")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, observers=observers)
    elif args.custom_agents:
        logger.info("Running custom agents example")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, observers=observers)
    else:  # Default or --all
        logger.info("Running all examples")
        from examples.basic_examples import run_examples
        run_examples(model=args.model, observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_7(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("Enabling observability features")
        observers.append(ConsoleObserver())
        observers.append(None)
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("Running class methods example")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, observers=observers)
    elif args.custom_agents:
        logger.info("Running custom agents example")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, observers=observers)
    else:  # Default or --all
        logger.info("Running all examples")
        from examples.basic_examples import run_examples
        run_examples(model=args.model, observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_8(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("Enabling observability features")
        observers.append(ConsoleObserver())
        observers.append(FileObserver(None))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("Running class methods example")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, observers=observers)
    elif args.custom_agents:
        logger.info("Running custom agents example")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, observers=observers)
    else:  # Default or --all
        logger.info("Running all examples")
        from examples.basic_examples import run_examples
        run_examples(model=args.model, observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_9(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("Enabling observability features")
        observers.append(ConsoleObserver())
        observers.append(FileObserver('XXagent_events.jsonlXX'))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("Running class methods example")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, observers=observers)
    elif args.custom_agents:
        logger.info("Running custom agents example")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, observers=observers)
    else:  # Default or --all
        logger.info("Running all examples")
        from examples.basic_examples import run_examples
        run_examples(model=args.model, observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_10(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("Enabling observability features")
        observers.append(ConsoleObserver())
        observers.append(FileObserver('AGENT_EVENTS.JSONL'))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("Running class methods example")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, observers=observers)
    elif args.custom_agents:
        logger.info("Running custom agents example")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, observers=observers)
    else:  # Default or --all
        logger.info("Running all examples")
        from examples.basic_examples import run_examples
        run_examples(model=args.model, observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_11(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("Enabling observability features")
        observers.append(ConsoleObserver())
        observers.append(FileObserver('agent_events.jsonl'))
        observers.append(None)
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("Running class methods example")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, observers=observers)
    elif args.custom_agents:
        logger.info("Running custom agents example")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, observers=observers)
    else:  # Default or --all
        logger.info("Running all examples")
        from examples.basic_examples import run_examples
        run_examples(model=args.model, observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_12(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("Enabling observability features")
        observers.append(ConsoleObserver())
        observers.append(FileObserver('agent_events.jsonl'))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info(None)
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, observers=observers)
    elif args.custom_agents:
        logger.info("Running custom agents example")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, observers=observers)
    else:  # Default or --all
        logger.info("Running all examples")
        from examples.basic_examples import run_examples
        run_examples(model=args.model, observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_13(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("Enabling observability features")
        observers.append(ConsoleObserver())
        observers.append(FileObserver('agent_events.jsonl'))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("XXRunning class methods exampleXX")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, observers=observers)
    elif args.custom_agents:
        logger.info("Running custom agents example")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, observers=observers)
    else:  # Default or --all
        logger.info("Running all examples")
        from examples.basic_examples import run_examples
        run_examples(model=args.model, observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_14(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("Enabling observability features")
        observers.append(ConsoleObserver())
        observers.append(FileObserver('agent_events.jsonl'))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("running class methods example")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, observers=observers)
    elif args.custom_agents:
        logger.info("Running custom agents example")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, observers=observers)
    else:  # Default or --all
        logger.info("Running all examples")
        from examples.basic_examples import run_examples
        run_examples(model=args.model, observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_15(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("Enabling observability features")
        observers.append(ConsoleObserver())
        observers.append(FileObserver('agent_events.jsonl'))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("RUNNING CLASS METHODS EXAMPLE")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, observers=observers)
    elif args.custom_agents:
        logger.info("Running custom agents example")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, observers=observers)
    else:  # Default or --all
        logger.info("Running all examples")
        from examples.basic_examples import run_examples
        run_examples(model=args.model, observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_16(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("Enabling observability features")
        observers.append(ConsoleObserver())
        observers.append(FileObserver('agent_events.jsonl'))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("Running class methods example")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=None, observers=observers)
    elif args.custom_agents:
        logger.info("Running custom agents example")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, observers=observers)
    else:  # Default or --all
        logger.info("Running all examples")
        from examples.basic_examples import run_examples
        run_examples(model=args.model, observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_17(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("Enabling observability features")
        observers.append(ConsoleObserver())
        observers.append(FileObserver('agent_events.jsonl'))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("Running class methods example")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, observers=None)
    elif args.custom_agents:
        logger.info("Running custom agents example")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, observers=observers)
    else:  # Default or --all
        logger.info("Running all examples")
        from examples.basic_examples import run_examples
        run_examples(model=args.model, observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_18(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("Enabling observability features")
        observers.append(ConsoleObserver())
        observers.append(FileObserver('agent_events.jsonl'))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("Running class methods example")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(observers=observers)
    elif args.custom_agents:
        logger.info("Running custom agents example")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, observers=observers)
    else:  # Default or --all
        logger.info("Running all examples")
        from examples.basic_examples import run_examples
        run_examples(model=args.model, observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_19(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("Enabling observability features")
        observers.append(ConsoleObserver())
        observers.append(FileObserver('agent_events.jsonl'))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("Running class methods example")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, )
    elif args.custom_agents:
        logger.info("Running custom agents example")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, observers=observers)
    else:  # Default or --all
        logger.info("Running all examples")
        from examples.basic_examples import run_examples
        run_examples(model=args.model, observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_20(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("Enabling observability features")
        observers.append(ConsoleObserver())
        observers.append(FileObserver('agent_events.jsonl'))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("Running class methods example")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, observers=observers)
    elif args.custom_agents:
        logger.info(None)
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, observers=observers)
    else:  # Default or --all
        logger.info("Running all examples")
        from examples.basic_examples import run_examples
        run_examples(model=args.model, observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_21(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("Enabling observability features")
        observers.append(ConsoleObserver())
        observers.append(FileObserver('agent_events.jsonl'))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("Running class methods example")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, observers=observers)
    elif args.custom_agents:
        logger.info("XXRunning custom agents exampleXX")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, observers=observers)
    else:  # Default or --all
        logger.info("Running all examples")
        from examples.basic_examples import run_examples
        run_examples(model=args.model, observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_22(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("Enabling observability features")
        observers.append(ConsoleObserver())
        observers.append(FileObserver('agent_events.jsonl'))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("Running class methods example")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, observers=observers)
    elif args.custom_agents:
        logger.info("running custom agents example")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, observers=observers)
    else:  # Default or --all
        logger.info("Running all examples")
        from examples.basic_examples import run_examples
        run_examples(model=args.model, observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_23(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("Enabling observability features")
        observers.append(ConsoleObserver())
        observers.append(FileObserver('agent_events.jsonl'))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("Running class methods example")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, observers=observers)
    elif args.custom_agents:
        logger.info("RUNNING CUSTOM AGENTS EXAMPLE")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, observers=observers)
    else:  # Default or --all
        logger.info("Running all examples")
        from examples.basic_examples import run_examples
        run_examples(model=args.model, observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_24(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("Enabling observability features")
        observers.append(ConsoleObserver())
        observers.append(FileObserver('agent_events.jsonl'))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("Running class methods example")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, observers=observers)
    elif args.custom_agents:
        logger.info("Running custom agents example")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=None, observers=observers)
    else:  # Default or --all
        logger.info("Running all examples")
        from examples.basic_examples import run_examples
        run_examples(model=args.model, observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_25(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("Enabling observability features")
        observers.append(ConsoleObserver())
        observers.append(FileObserver('agent_events.jsonl'))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("Running class methods example")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, observers=observers)
    elif args.custom_agents:
        logger.info("Running custom agents example")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, observers=None)
    else:  # Default or --all
        logger.info("Running all examples")
        from examples.basic_examples import run_examples
        run_examples(model=args.model, observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_26(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("Enabling observability features")
        observers.append(ConsoleObserver())
        observers.append(FileObserver('agent_events.jsonl'))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("Running class methods example")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, observers=observers)
    elif args.custom_agents:
        logger.info("Running custom agents example")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(observers=observers)
    else:  # Default or --all
        logger.info("Running all examples")
        from examples.basic_examples import run_examples
        run_examples(model=args.model, observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_27(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("Enabling observability features")
        observers.append(ConsoleObserver())
        observers.append(FileObserver('agent_events.jsonl'))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("Running class methods example")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, observers=observers)
    elif args.custom_agents:
        logger.info("Running custom agents example")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, )
    else:  # Default or --all
        logger.info("Running all examples")
        from examples.basic_examples import run_examples
        run_examples(model=args.model, observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_28(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("Enabling observability features")
        observers.append(ConsoleObserver())
        observers.append(FileObserver('agent_events.jsonl'))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("Running class methods example")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, observers=observers)
    elif args.custom_agents:
        logger.info("Running custom agents example")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, observers=observers)
    else:  # Default or --all
        logger.info(None)
        from examples.basic_examples import run_examples
        run_examples(model=args.model, observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_29(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("Enabling observability features")
        observers.append(ConsoleObserver())
        observers.append(FileObserver('agent_events.jsonl'))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("Running class methods example")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, observers=observers)
    elif args.custom_agents:
        logger.info("Running custom agents example")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, observers=observers)
    else:  # Default or --all
        logger.info("XXRunning all examplesXX")
        from examples.basic_examples import run_examples
        run_examples(model=args.model, observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_30(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("Enabling observability features")
        observers.append(ConsoleObserver())
        observers.append(FileObserver('agent_events.jsonl'))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("Running class methods example")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, observers=observers)
    elif args.custom_agents:
        logger.info("Running custom agents example")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, observers=observers)
    else:  # Default or --all
        logger.info("running all examples")
        from examples.basic_examples import run_examples
        run_examples(model=args.model, observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_31(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("Enabling observability features")
        observers.append(ConsoleObserver())
        observers.append(FileObserver('agent_events.jsonl'))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("Running class methods example")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, observers=observers)
    elif args.custom_agents:
        logger.info("Running custom agents example")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, observers=observers)
    else:  # Default or --all
        logger.info("RUNNING ALL EXAMPLES")
        from examples.basic_examples import run_examples
        run_examples(model=args.model, observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_32(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("Enabling observability features")
        observers.append(ConsoleObserver())
        observers.append(FileObserver('agent_events.jsonl'))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("Running class methods example")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, observers=observers)
    elif args.custom_agents:
        logger.info("Running custom agents example")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, observers=observers)
    else:  # Default or --all
        logger.info("Running all examples")
        from examples.basic_examples import run_examples
        run_examples(model=None, observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_33(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("Enabling observability features")
        observers.append(ConsoleObserver())
        observers.append(FileObserver('agent_events.jsonl'))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("Running class methods example")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, observers=observers)
    elif args.custom_agents:
        logger.info("Running custom agents example")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, observers=observers)
    else:  # Default or --all
        logger.info("Running all examples")
        from examples.basic_examples import run_examples
        run_examples(model=args.model, observers=None)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_34(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("Enabling observability features")
        observers.append(ConsoleObserver())
        observers.append(FileObserver('agent_events.jsonl'))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("Running class methods example")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, observers=observers)
    elif args.custom_agents:
        logger.info("Running custom agents example")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, observers=observers)
    else:  # Default or --all
        logger.info("Running all examples")
        from examples.basic_examples import run_examples
        run_examples(observers=observers)
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

def x_run_examples__mutmut_35(args):
    """Run examples based on command line arguments."""
    # Set up observers if enabled
    observers = []
    if args.enable_observability:
        logger.info("Enabling observability features")
        observers.append(ConsoleObserver())
        observers.append(FileObserver('agent_events.jsonl'))
        observers.append(TreeTraceObserver())
        
    # Determine which examples to run
    if args.class_methods:
        logger.info("Running class methods example")
        from examples.basic_examples import run_class_methods_example
        run_class_methods_example(model=args.model, observers=observers)
    elif args.custom_agents:
        logger.info("Running custom agents example")
        from examples.basic_examples import run_custom_agents_example
        run_custom_agents_example(model=args.model, observers=observers)
    else:  # Default or --all
        logger.info("Running all examples")
        from examples.basic_examples import run_examples
        run_examples(model=args.model, )
        
    # Print tree trace if observability is enabled
    if args.enable_observability:
        for observer in observers:
            if isinstance(observer, TreeTraceObserver):
                observer.print_trace()

x_run_examples__mutmut_mutants : ClassVar[MutantDict] = {
'x_run_examples__mutmut_1': x_run_examples__mutmut_1, 
    'x_run_examples__mutmut_2': x_run_examples__mutmut_2, 
    'x_run_examples__mutmut_3': x_run_examples__mutmut_3, 
    'x_run_examples__mutmut_4': x_run_examples__mutmut_4, 
    'x_run_examples__mutmut_5': x_run_examples__mutmut_5, 
    'x_run_examples__mutmut_6': x_run_examples__mutmut_6, 
    'x_run_examples__mutmut_7': x_run_examples__mutmut_7, 
    'x_run_examples__mutmut_8': x_run_examples__mutmut_8, 
    'x_run_examples__mutmut_9': x_run_examples__mutmut_9, 
    'x_run_examples__mutmut_10': x_run_examples__mutmut_10, 
    'x_run_examples__mutmut_11': x_run_examples__mutmut_11, 
    'x_run_examples__mutmut_12': x_run_examples__mutmut_12, 
    'x_run_examples__mutmut_13': x_run_examples__mutmut_13, 
    'x_run_examples__mutmut_14': x_run_examples__mutmut_14, 
    'x_run_examples__mutmut_15': x_run_examples__mutmut_15, 
    'x_run_examples__mutmut_16': x_run_examples__mutmut_16, 
    'x_run_examples__mutmut_17': x_run_examples__mutmut_17, 
    'x_run_examples__mutmut_18': x_run_examples__mutmut_18, 
    'x_run_examples__mutmut_19': x_run_examples__mutmut_19, 
    'x_run_examples__mutmut_20': x_run_examples__mutmut_20, 
    'x_run_examples__mutmut_21': x_run_examples__mutmut_21, 
    'x_run_examples__mutmut_22': x_run_examples__mutmut_22, 
    'x_run_examples__mutmut_23': x_run_examples__mutmut_23, 
    'x_run_examples__mutmut_24': x_run_examples__mutmut_24, 
    'x_run_examples__mutmut_25': x_run_examples__mutmut_25, 
    'x_run_examples__mutmut_26': x_run_examples__mutmut_26, 
    'x_run_examples__mutmut_27': x_run_examples__mutmut_27, 
    'x_run_examples__mutmut_28': x_run_examples__mutmut_28, 
    'x_run_examples__mutmut_29': x_run_examples__mutmut_29, 
    'x_run_examples__mutmut_30': x_run_examples__mutmut_30, 
    'x_run_examples__mutmut_31': x_run_examples__mutmut_31, 
    'x_run_examples__mutmut_32': x_run_examples__mutmut_32, 
    'x_run_examples__mutmut_33': x_run_examples__mutmut_33, 
    'x_run_examples__mutmut_34': x_run_examples__mutmut_34, 
    'x_run_examples__mutmut_35': x_run_examples__mutmut_35
}

def run_examples(*args, **kwargs):
    result = _mutmut_trampoline(x_run_examples__mutmut_orig, x_run_examples__mutmut_mutants, args, kwargs)
    return result 

run_examples.__signature__ = _mutmut_signature(x_run_examples__mutmut_orig)
x_run_examples__mutmut_orig.__name__ = 'x_run_examples'

def x_handle_model_prefix__mutmut_orig(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_1(model_name, use_ollama=True):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_2(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = None
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_3(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['XXopenaiXX', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_4(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['OPENAI', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_5(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'XXanthropicXX', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_6(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'ANTHROPIC', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_7(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'XXgoogleXX']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_8(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'GOOGLE']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_9(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = None
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_10(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['XXollamaXX']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_11(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['OLLAMA']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_12(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = None
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_13(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['XXllama-3XX', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_14(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['LLAMA-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_15(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'XXllama-3.1XX', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_16(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'LLAMA-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_17(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'XXmixtralXX', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_18(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'MIXTRAL', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_19(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'XXgemmaXX']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_20(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'GEMMA']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_21(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if 'XX/XX' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_22(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' not in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_23(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = None
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_24(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split(None, 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_25(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', None)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_26(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split(1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_27(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', )
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_28(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.rsplit('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_29(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('XX/XX', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_30(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 2)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_31(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.upper() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_32(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() not in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_33(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.upper() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_34(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() != 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_35(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'XXgroqXX':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_36(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'GROQ':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_37(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.upper() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_38(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() not in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_39(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(None)
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_40(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model not in model_name.lower():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_41(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.upper():
            logger.info(f"Model name '{model_name}' looks like a Groq model, adding 'groq/' prefix")
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

def x_handle_model_prefix__mutmut_42(model_name, use_ollama=False):
    """
    Handle model provider prefixes correctly.
    
    Args:
        model_name: The model name that might include a provider prefix
        use_ollama: Whether to use Ollama for local inference
        
    Returns:
        Correctly formatted model name
    """
    # Common providers that don't need prefixes
    no_prefix_providers = ['openai', 'anthropic', 'google']
    
    # Providers that need to keep their prefix
    keep_prefix_providers = ['ollama']
    
    # Special case for Groq models - they need the groq/ prefix
    groq_models = ['llama-3', 'llama-3.1', 'mixtral', 'gemma']
    
    # Check if model has a provider prefix (format: "provider/model")
    if '/' in model_name:
        provider, model = model_name.split('/', 1)
        
        # For providers that don't need prefixes, just return the model part
        if provider.lower() in no_prefix_providers:
            return model
            
        # Groq models keep their prefix
        if provider.lower() == 'groq':
            return model_name
            
        # For other providers that need to keep their prefix, return as is
        if provider.lower() in keep_prefix_providers:
            return model_name
            
        # For unknown providers, log a warning but keep the full name
        logger.warning(f"Unknown provider prefix '{provider}', keeping full model name")
        return model_name
    
    # If no provider prefix but looks like a Groq model, add groq prefix
    for groq_model in groq_models:
        if groq_model in model_name.lower():
            logger.info(None)
            return f"groq/{model_name}"
    
    # If no provider prefix and --ollama flag is used, add ollama prefix
    if use_ollama:
        return f"ollama/{model_name}"
    
    # No changes needed
    return model_name

x_handle_model_prefix__mutmut_mutants : ClassVar[MutantDict] = {
'x_handle_model_prefix__mutmut_1': x_handle_model_prefix__mutmut_1, 
    'x_handle_model_prefix__mutmut_2': x_handle_model_prefix__mutmut_2, 
    'x_handle_model_prefix__mutmut_3': x_handle_model_prefix__mutmut_3, 
    'x_handle_model_prefix__mutmut_4': x_handle_model_prefix__mutmut_4, 
    'x_handle_model_prefix__mutmut_5': x_handle_model_prefix__mutmut_5, 
    'x_handle_model_prefix__mutmut_6': x_handle_model_prefix__mutmut_6, 
    'x_handle_model_prefix__mutmut_7': x_handle_model_prefix__mutmut_7, 
    'x_handle_model_prefix__mutmut_8': x_handle_model_prefix__mutmut_8, 
    'x_handle_model_prefix__mutmut_9': x_handle_model_prefix__mutmut_9, 
    'x_handle_model_prefix__mutmut_10': x_handle_model_prefix__mutmut_10, 
    'x_handle_model_prefix__mutmut_11': x_handle_model_prefix__mutmut_11, 
    'x_handle_model_prefix__mutmut_12': x_handle_model_prefix__mutmut_12, 
    'x_handle_model_prefix__mutmut_13': x_handle_model_prefix__mutmut_13, 
    'x_handle_model_prefix__mutmut_14': x_handle_model_prefix__mutmut_14, 
    'x_handle_model_prefix__mutmut_15': x_handle_model_prefix__mutmut_15, 
    'x_handle_model_prefix__mutmut_16': x_handle_model_prefix__mutmut_16, 
    'x_handle_model_prefix__mutmut_17': x_handle_model_prefix__mutmut_17, 
    'x_handle_model_prefix__mutmut_18': x_handle_model_prefix__mutmut_18, 
    'x_handle_model_prefix__mutmut_19': x_handle_model_prefix__mutmut_19, 
    'x_handle_model_prefix__mutmut_20': x_handle_model_prefix__mutmut_20, 
    'x_handle_model_prefix__mutmut_21': x_handle_model_prefix__mutmut_21, 
    'x_handle_model_prefix__mutmut_22': x_handle_model_prefix__mutmut_22, 
    'x_handle_model_prefix__mutmut_23': x_handle_model_prefix__mutmut_23, 
    'x_handle_model_prefix__mutmut_24': x_handle_model_prefix__mutmut_24, 
    'x_handle_model_prefix__mutmut_25': x_handle_model_prefix__mutmut_25, 
    'x_handle_model_prefix__mutmut_26': x_handle_model_prefix__mutmut_26, 
    'x_handle_model_prefix__mutmut_27': x_handle_model_prefix__mutmut_27, 
    'x_handle_model_prefix__mutmut_28': x_handle_model_prefix__mutmut_28, 
    'x_handle_model_prefix__mutmut_29': x_handle_model_prefix__mutmut_29, 
    'x_handle_model_prefix__mutmut_30': x_handle_model_prefix__mutmut_30, 
    'x_handle_model_prefix__mutmut_31': x_handle_model_prefix__mutmut_31, 
    'x_handle_model_prefix__mutmut_32': x_handle_model_prefix__mutmut_32, 
    'x_handle_model_prefix__mutmut_33': x_handle_model_prefix__mutmut_33, 
    'x_handle_model_prefix__mutmut_34': x_handle_model_prefix__mutmut_34, 
    'x_handle_model_prefix__mutmut_35': x_handle_model_prefix__mutmut_35, 
    'x_handle_model_prefix__mutmut_36': x_handle_model_prefix__mutmut_36, 
    'x_handle_model_prefix__mutmut_37': x_handle_model_prefix__mutmut_37, 
    'x_handle_model_prefix__mutmut_38': x_handle_model_prefix__mutmut_38, 
    'x_handle_model_prefix__mutmut_39': x_handle_model_prefix__mutmut_39, 
    'x_handle_model_prefix__mutmut_40': x_handle_model_prefix__mutmut_40, 
    'x_handle_model_prefix__mutmut_41': x_handle_model_prefix__mutmut_41, 
    'x_handle_model_prefix__mutmut_42': x_handle_model_prefix__mutmut_42
}

def handle_model_prefix(*args, **kwargs):
    result = _mutmut_trampoline(x_handle_model_prefix__mutmut_orig, x_handle_model_prefix__mutmut_mutants, args, kwargs)
    return result 

handle_model_prefix.__signature__ = _mutmut_signature(x_handle_model_prefix__mutmut_orig)
x_handle_model_prefix__mutmut_orig.__name__ = 'x_handle_model_prefix'

def x_print_sample_tool_definitions__mutmut_orig():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_1():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info(None)
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_2():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("XXPrinting sample tool definitionsXX")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_3():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_4():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("PRINTING SAMPLE TOOL DEFINITIONS")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_5():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "XXtodayXX") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_6():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "TODAY") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_7():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "XXaddXX") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_8():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "ADD") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_9():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation != "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_10():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "XXaddXX":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_11():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "ADD":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_12():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a - b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_13():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation != "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_14():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "XXsubtractXX":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_15():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "SUBTRACT":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_16():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a + b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_17():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation != "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_18():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "XXmultiplyXX":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_19():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "MULTIPLY":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_20():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a / b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_21():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation != "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_22():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "XXdivideXX":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_23():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "DIVIDE":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_24():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a * b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_25():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(None)
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_26():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a - b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_27():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape != "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_28():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "XXcircleXX":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_29():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "CIRCLE":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_30():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "XXradiusXX" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_31():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "RADIUS" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_32():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_33():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError(None)
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_34():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("XXRadius is required for circleXX")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_35():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_36():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("RADIUS IS REQUIRED FOR CIRCLE")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_37():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 / kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_38():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 4.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_39():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] * 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_40():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["XXradiusXX"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_41():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["RADIUS"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_42():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 3
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_43():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape != "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_44():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "XXrectangleXX":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_45():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "RECTANGLE":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_46():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs and "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_47():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "XXwidthXX" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_48():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "WIDTH" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_49():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_50():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "XXheightXX" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_51():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "HEIGHT" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_52():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_53():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError(None)
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_54():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("XXWidth and height are required for rectangleXX")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_55():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_56():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("WIDTH AND HEIGHT ARE REQUIRED FOR RECTANGLE")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_57():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] / kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_58():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["XXwidthXX"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_59():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["WIDTH"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_60():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["XXheightXX"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_61():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["HEIGHT"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_62():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape != "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_63():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "XXtriangleXX":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_64():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "TRIANGLE":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_65():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs and "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_66():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "XXbaseXX" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_67():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "BASE" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_68():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_69():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "XXheightXX" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_70():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "HEIGHT" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_71():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_72():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError(None)
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_73():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("XXBase and height are required for triangleXX")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_74():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_75():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("BASE AND HEIGHT ARE REQUIRED FOR TRIANGLE")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_76():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] / kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_77():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 / kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_78():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 1.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_79():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["XXbaseXX"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_80():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["BASE"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_81():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["XXheightXX"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_82():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["HEIGHT"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_83():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(None)
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_84():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = None
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_85():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = None
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_86():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = None
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_87():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(None)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_88():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = None
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_89():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(None)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_90():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = None
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_91():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(None, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_92():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, None)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_93():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_94():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, )
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_95():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = None
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_96():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(None, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_97():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, None)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_98():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_99():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, )
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_100():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = None
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_101():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions(None)
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_102():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print(None)
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_103():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("XX\n==== Sample Tool Definitions ====XX")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_104():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== sample tool definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_105():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== SAMPLE TOOL DEFINITIONS ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_106():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print(None)
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_107():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("XXThese are examples of function definitions that would be sent to the LLM.XX")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_108():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("these are examples of function definitions that would be sent to the llm.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_109():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("THESE ARE EXAMPLES OF FUNCTION DEFINITIONS THAT WOULD BE SENT TO THE LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_110():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print(None)
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_111():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("XXThe examples demonstrate different ways to define tools:XX")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_112():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("the examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_113():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("THE EXAMPLES DEMONSTRATE DIFFERENT WAYS TO DEFINE TOOLS:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_114():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print(None)
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_115():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("XX  - Regular functions wrapped with FunctionToolXX")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_116():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - regular functions wrapped with functiontool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_117():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - REGULAR FUNCTIONS WRAPPED WITH FUNCTIONTOOL")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_118():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print(None)
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_119():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("XX  - Functions decorated with @liteagent_toolXX")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_120():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_121():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - FUNCTIONS DECORATED WITH @LITEAGENT_TOOL")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_122():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print(None)
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_123():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("XX  - Class methods wrapped with InstanceMethodToolXX")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_124():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - class methods wrapped with instancemethodtool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_125():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - CLASS METHODS WRAPPED WITH INSTANCEMETHODTOOL")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_126():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print(None)
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_127():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("XX  - Class methods decorated with @liteagent_tool\nXX")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_128():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_129():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - CLASS METHODS DECORATED WITH @LITEAGENT_TOOL\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_130():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(None)
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_131():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(None, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_132():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=None))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_133():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_134():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, ))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_135():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=3))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_136():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print(None)
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_137():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("XX\n==== End of Sample Tool Definitions ====\nXX")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_138():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== end of sample tool definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_139():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== END OF SAMPLE TOOL DEFINITIONS ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_140():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print(None)
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_141():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("XX\n==== Example Usage Code ====XX")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_142():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== example usage code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_143():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== EXAMPLE USAGE CODE ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_144():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print(None)
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_145():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("XXHere's how to implement these patterns in your own code:XX")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_146():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_147():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("HERE'S HOW TO IMPLEMENT THESE PATTERNS IN YOUR OWN CODE:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_148():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print(None)
    print("\n==== End of Example Usage Code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_149():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print(None)
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_150():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("XX\n==== End of Example Usage Code ====\nXX")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_151():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== end of example usage code ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

def x_print_sample_tool_definitions__mutmut_152():
    """Print sample tool definitions as they would be sent to the LLM."""
    logger.info("Printing sample tool definitions")
    
    # Import the decorator
    from liteagent.tools import liteagent_tool
    
    # Example 1: Basic function tools
    def get_weather(city: str, date: str = "today") -> str:
        """Gets weather forecast for a city.
        
        This function retrieves weather forecast for the specified city.
        For accurate results, provide a valid city name.
        
        Args:
            city: The name of the city to get weather for
            date: The date to get weather for (default: today)
            
        Returns:
            A string containing the weather forecast
        """
        return f"Weather forecast for {city} on {date}"
    
    def calculate(a: float, b: float, operation: str = "add") -> float:
        """Performs calculations on two numbers.
        
        This tool can perform basic arithmetic operations on two numbers.
        
        Args:
            a: First number
            b: Second number
            operation: Operation to perform, one of: add, subtract, multiply, divide
            
        Returns:
            Result of the calculation
        """
        if operation == "add":
            return a + b
        elif operation == "subtract":
            return a - b
        elif operation == "multiply":
            return a * b
        elif operation == "divide":
            return a / b
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    # Example 2: Function with the @liteagent_tool decorator (basic usage)
    @liteagent_tool
    def search_database(query: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """Searches the database for the given query.
        
        Performs a search in the system database and returns matching records.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return (default: 10)
            offset: Number of results to skip for pagination (default: 0)
            
        Returns:
            List of matching records
        """
        # This is a mock function for demonstration
        return [{"id": 1, "title": "Sample result"}]
    
    # Example 3: Function with @liteagent_tool decorator with custom name and description
    @liteagent_tool(
        name="find_location",
        description="Find geographic coordinates for a location"
    )
    def get_coordinates(location: str) -> Dict[str, float]:
        """Get the latitude and longitude for a location.
        
        Args:
            location: The name of the location (city, address, landmark)
            
        Returns:
            Dictionary with latitude and longitude
        """
        # Mock implementation
        return {"latitude": 37.7749, "longitude": -122.4194}
    
    # Example 4: Class with methods using decorators
    class ToolsWithDecorators:
        """Class demonstrating tools with decorators."""
        
        @liteagent_tool
        def get_user_profile(self, user_id: str) -> Dict:
            """Get detailed profile information for a user.
            
            Retrieves comprehensive user information including preferences,
            settings, and activity history.
            
            Args:
                user_id: The ID of the user to lookup
                
            Returns:
                Dictionary with user profile information
            """
            return {
                "id": user_id,
                "name": "Sample User",
                "email": "user@example.com",
                "joined": "2023-01-15"
            }
            
        @liteagent_tool(
            name="analyze_text_sentiment",
            description="Analyze the sentiment of a text passage"
        )
        def analyze_sentiment(self, text: str) -> Dict[str, Any]:
            """Analyze the sentiment of a text passage.
            
            Performs sentiment analysis on the provided text and returns
            scores for positive, negative, and neutral sentiment.
            
            Args:
                text: The text to analyze
                
            Returns:
                Dictionary with sentiment scores
            """
            # Mock implementation
            return {
                "positive": 0.65,
                "negative": 0.15,
                "neutral": 0.20,
                "overall": "positive"
            }
    
    # Example 5: Standard class with methods
    class MathTools:
        """Sample class with method tools."""
        
        def add_numbers(self, a: int, b: int) -> int:
            """Adds two numbers together and returns the result.
            
            This is a simple addition operation.
            
            Args:
                a: First number to add
                b: Second number to add
                
            Returns:
                The sum of a and b
            """
            return a + b
            
        def calculate_area(self, shape: str, **kwargs) -> float:
            """Calculate the area of a geometric shape.
            
            This tool calculates the area of various geometric shapes.
            For a circle, provide radius.
            For a rectangle, provide width and height.
            For a triangle, provide base and height.
            
            Args:
                shape: The type of shape (circle, rectangle, triangle)
                **kwargs: Shape-specific parameters
                
            Returns:
                The calculated area
            """
            if shape == "circle":
                if "radius" not in kwargs:
                    raise ValueError("Radius is required for circle")
                return 3.14159 * kwargs["radius"] ** 2
            elif shape == "rectangle":
                if "width" not in kwargs or "height" not in kwargs:
                    raise ValueError("Width and height are required for rectangle")
                return kwargs["width"] * kwargs["height"]
            elif shape == "triangle":
                if "base" not in kwargs or "height" not in kwargs:
                    raise ValueError("Base and height are required for triangle")
                return 0.5 * kwargs["base"] * kwargs["height"]
            else:
                raise ValueError(f"Unknown shape: {shape}")
    
    # Create instances and collect tools
    tools_with_decorators = ToolsWithDecorators()
    math_tools = MathTools()
    
    # Create standard tool objects
    weather_tool = FunctionTool(get_weather)
    calculate_tool = FunctionTool(calculate)
    
    # Create instance method tools
    add_numbers_tool = InstanceMethodTool(math_tools.add_numbers, math_tools)
    calculate_area_tool = InstanceMethodTool(math_tools.calculate_area, math_tools)
    
    # Get function definitions
    # Note: Decorated functions are already wrapped as tools
    function_definitions = get_function_definitions([
        # Standard function tools
        weather_tool,
        calculate_tool,
        
        # Decorated standalone functions
        search_database,
        get_coordinates,
        
        # Instance method tools (regular way)
        add_numbers_tool,
        calculate_area_tool,
        
        # Instance methods with decorators
        tools_with_decorators.get_user_profile,
        tools_with_decorators.analyze_sentiment
    ])
    
    # Print the definitions in a pretty format
    print("\n==== Sample Tool Definitions ====")
    print("These are examples of function definitions that would be sent to the LLM.")
    print("The examples demonstrate different ways to define tools:")
    print("  - Regular functions wrapped with FunctionTool")
    print("  - Functions decorated with @liteagent_tool")
    print("  - Class methods wrapped with InstanceMethodTool")
    print("  - Class methods decorated with @liteagent_tool\n")
    print(json.dumps(function_definitions, indent=2))
    print("\n==== End of Sample Tool Definitions ====\n")
    
    # Print example code for using these patterns
    print("\n==== Example Usage Code ====")
    print("Here's how to implement these patterns in your own code:")
    print("""
# Import required components
from liteagent import LiteAgent
from liteagent.tools import FunctionTool, InstanceMethodTool, liteagent_tool

# Pattern 1: Regular function + FunctionTool
def get_weather(city: str) -> str:
    \"\"\"Gets weather forecast for a city.\"\"\"
    # Implementation here
    pass

# Create explicit tool object
weather_tool = FunctionTool(get_weather)

# Pattern 2: Function with decorator
@liteagent_tool
def search_database(query: str) -> list:
    \"\"\"Search the database for information.\"\"\"
    # Implementation here
    pass

# Pattern 3: Decorator with custom parameters
@liteagent_tool(
    name="find_user",
    description="Find a user by ID or email"
)
def get_user(user_identifier: str) -> dict:
    \"\"\"Find user by ID or email.\"\"\"
    # Implementation here
    pass

# Pattern 4: Class with decorated methods
class UserTools:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    @liteagent_tool
    def get_profile(self, user_id: str) -> dict:
        \"\"\"Get user profile information.\"\"\"
        # Implementation here
        pass

# Create an agent with a mix of tools
user_tools = UserTools(api_key="your-api-key")

agent = LiteAgent(
    model="gpt-4o-mini",
    system_prompt="You are a helpful assistant with tools.",
    tools=[
        # Mix of different tool types
        weather_tool,              # Regular FunctionTool
        search_database,           # Decorated function
        get_user,                  # Decorated function with custom parameters
        user_tools.get_profile     # Decorated method from class instance
    ]
)

# Use the agent
response = agent.chat("Please get the weather in San Francisco")
""")
    print("\n==== END OF EXAMPLE USAGE CODE ====\n")
    
    # Return the definitions for potential further use
    return function_definitions

x_print_sample_tool_definitions__mutmut_mutants : ClassVar[MutantDict] = {
'x_print_sample_tool_definitions__mutmut_1': x_print_sample_tool_definitions__mutmut_1, 
    'x_print_sample_tool_definitions__mutmut_2': x_print_sample_tool_definitions__mutmut_2, 
    'x_print_sample_tool_definitions__mutmut_3': x_print_sample_tool_definitions__mutmut_3, 
    'x_print_sample_tool_definitions__mutmut_4': x_print_sample_tool_definitions__mutmut_4, 
    'x_print_sample_tool_definitions__mutmut_5': x_print_sample_tool_definitions__mutmut_5, 
    'x_print_sample_tool_definitions__mutmut_6': x_print_sample_tool_definitions__mutmut_6, 
    'x_print_sample_tool_definitions__mutmut_7': x_print_sample_tool_definitions__mutmut_7, 
    'x_print_sample_tool_definitions__mutmut_8': x_print_sample_tool_definitions__mutmut_8, 
    'x_print_sample_tool_definitions__mutmut_9': x_print_sample_tool_definitions__mutmut_9, 
    'x_print_sample_tool_definitions__mutmut_10': x_print_sample_tool_definitions__mutmut_10, 
    'x_print_sample_tool_definitions__mutmut_11': x_print_sample_tool_definitions__mutmut_11, 
    'x_print_sample_tool_definitions__mutmut_12': x_print_sample_tool_definitions__mutmut_12, 
    'x_print_sample_tool_definitions__mutmut_13': x_print_sample_tool_definitions__mutmut_13, 
    'x_print_sample_tool_definitions__mutmut_14': x_print_sample_tool_definitions__mutmut_14, 
    'x_print_sample_tool_definitions__mutmut_15': x_print_sample_tool_definitions__mutmut_15, 
    'x_print_sample_tool_definitions__mutmut_16': x_print_sample_tool_definitions__mutmut_16, 
    'x_print_sample_tool_definitions__mutmut_17': x_print_sample_tool_definitions__mutmut_17, 
    'x_print_sample_tool_definitions__mutmut_18': x_print_sample_tool_definitions__mutmut_18, 
    'x_print_sample_tool_definitions__mutmut_19': x_print_sample_tool_definitions__mutmut_19, 
    'x_print_sample_tool_definitions__mutmut_20': x_print_sample_tool_definitions__mutmut_20, 
    'x_print_sample_tool_definitions__mutmut_21': x_print_sample_tool_definitions__mutmut_21, 
    'x_print_sample_tool_definitions__mutmut_22': x_print_sample_tool_definitions__mutmut_22, 
    'x_print_sample_tool_definitions__mutmut_23': x_print_sample_tool_definitions__mutmut_23, 
    'x_print_sample_tool_definitions__mutmut_24': x_print_sample_tool_definitions__mutmut_24, 
    'x_print_sample_tool_definitions__mutmut_25': x_print_sample_tool_definitions__mutmut_25, 
    'x_print_sample_tool_definitions__mutmut_26': x_print_sample_tool_definitions__mutmut_26, 
    'x_print_sample_tool_definitions__mutmut_27': x_print_sample_tool_definitions__mutmut_27, 
    'x_print_sample_tool_definitions__mutmut_28': x_print_sample_tool_definitions__mutmut_28, 
    'x_print_sample_tool_definitions__mutmut_29': x_print_sample_tool_definitions__mutmut_29, 
    'x_print_sample_tool_definitions__mutmut_30': x_print_sample_tool_definitions__mutmut_30, 
    'x_print_sample_tool_definitions__mutmut_31': x_print_sample_tool_definitions__mutmut_31, 
    'x_print_sample_tool_definitions__mutmut_32': x_print_sample_tool_definitions__mutmut_32, 
    'x_print_sample_tool_definitions__mutmut_33': x_print_sample_tool_definitions__mutmut_33, 
    'x_print_sample_tool_definitions__mutmut_34': x_print_sample_tool_definitions__mutmut_34, 
    'x_print_sample_tool_definitions__mutmut_35': x_print_sample_tool_definitions__mutmut_35, 
    'x_print_sample_tool_definitions__mutmut_36': x_print_sample_tool_definitions__mutmut_36, 
    'x_print_sample_tool_definitions__mutmut_37': x_print_sample_tool_definitions__mutmut_37, 
    'x_print_sample_tool_definitions__mutmut_38': x_print_sample_tool_definitions__mutmut_38, 
    'x_print_sample_tool_definitions__mutmut_39': x_print_sample_tool_definitions__mutmut_39, 
    'x_print_sample_tool_definitions__mutmut_40': x_print_sample_tool_definitions__mutmut_40, 
    'x_print_sample_tool_definitions__mutmut_41': x_print_sample_tool_definitions__mutmut_41, 
    'x_print_sample_tool_definitions__mutmut_42': x_print_sample_tool_definitions__mutmut_42, 
    'x_print_sample_tool_definitions__mutmut_43': x_print_sample_tool_definitions__mutmut_43, 
    'x_print_sample_tool_definitions__mutmut_44': x_print_sample_tool_definitions__mutmut_44, 
    'x_print_sample_tool_definitions__mutmut_45': x_print_sample_tool_definitions__mutmut_45, 
    'x_print_sample_tool_definitions__mutmut_46': x_print_sample_tool_definitions__mutmut_46, 
    'x_print_sample_tool_definitions__mutmut_47': x_print_sample_tool_definitions__mutmut_47, 
    'x_print_sample_tool_definitions__mutmut_48': x_print_sample_tool_definitions__mutmut_48, 
    'x_print_sample_tool_definitions__mutmut_49': x_print_sample_tool_definitions__mutmut_49, 
    'x_print_sample_tool_definitions__mutmut_50': x_print_sample_tool_definitions__mutmut_50, 
    'x_print_sample_tool_definitions__mutmut_51': x_print_sample_tool_definitions__mutmut_51, 
    'x_print_sample_tool_definitions__mutmut_52': x_print_sample_tool_definitions__mutmut_52, 
    'x_print_sample_tool_definitions__mutmut_53': x_print_sample_tool_definitions__mutmut_53, 
    'x_print_sample_tool_definitions__mutmut_54': x_print_sample_tool_definitions__mutmut_54, 
    'x_print_sample_tool_definitions__mutmut_55': x_print_sample_tool_definitions__mutmut_55, 
    'x_print_sample_tool_definitions__mutmut_56': x_print_sample_tool_definitions__mutmut_56, 
    'x_print_sample_tool_definitions__mutmut_57': x_print_sample_tool_definitions__mutmut_57, 
    'x_print_sample_tool_definitions__mutmut_58': x_print_sample_tool_definitions__mutmut_58, 
    'x_print_sample_tool_definitions__mutmut_59': x_print_sample_tool_definitions__mutmut_59, 
    'x_print_sample_tool_definitions__mutmut_60': x_print_sample_tool_definitions__mutmut_60, 
    'x_print_sample_tool_definitions__mutmut_61': x_print_sample_tool_definitions__mutmut_61, 
    'x_print_sample_tool_definitions__mutmut_62': x_print_sample_tool_definitions__mutmut_62, 
    'x_print_sample_tool_definitions__mutmut_63': x_print_sample_tool_definitions__mutmut_63, 
    'x_print_sample_tool_definitions__mutmut_64': x_print_sample_tool_definitions__mutmut_64, 
    'x_print_sample_tool_definitions__mutmut_65': x_print_sample_tool_definitions__mutmut_65, 
    'x_print_sample_tool_definitions__mutmut_66': x_print_sample_tool_definitions__mutmut_66, 
    'x_print_sample_tool_definitions__mutmut_67': x_print_sample_tool_definitions__mutmut_67, 
    'x_print_sample_tool_definitions__mutmut_68': x_print_sample_tool_definitions__mutmut_68, 
    'x_print_sample_tool_definitions__mutmut_69': x_print_sample_tool_definitions__mutmut_69, 
    'x_print_sample_tool_definitions__mutmut_70': x_print_sample_tool_definitions__mutmut_70, 
    'x_print_sample_tool_definitions__mutmut_71': x_print_sample_tool_definitions__mutmut_71, 
    'x_print_sample_tool_definitions__mutmut_72': x_print_sample_tool_definitions__mutmut_72, 
    'x_print_sample_tool_definitions__mutmut_73': x_print_sample_tool_definitions__mutmut_73, 
    'x_print_sample_tool_definitions__mutmut_74': x_print_sample_tool_definitions__mutmut_74, 
    'x_print_sample_tool_definitions__mutmut_75': x_print_sample_tool_definitions__mutmut_75, 
    'x_print_sample_tool_definitions__mutmut_76': x_print_sample_tool_definitions__mutmut_76, 
    'x_print_sample_tool_definitions__mutmut_77': x_print_sample_tool_definitions__mutmut_77, 
    'x_print_sample_tool_definitions__mutmut_78': x_print_sample_tool_definitions__mutmut_78, 
    'x_print_sample_tool_definitions__mutmut_79': x_print_sample_tool_definitions__mutmut_79, 
    'x_print_sample_tool_definitions__mutmut_80': x_print_sample_tool_definitions__mutmut_80, 
    'x_print_sample_tool_definitions__mutmut_81': x_print_sample_tool_definitions__mutmut_81, 
    'x_print_sample_tool_definitions__mutmut_82': x_print_sample_tool_definitions__mutmut_82, 
    'x_print_sample_tool_definitions__mutmut_83': x_print_sample_tool_definitions__mutmut_83, 
    'x_print_sample_tool_definitions__mutmut_84': x_print_sample_tool_definitions__mutmut_84, 
    'x_print_sample_tool_definitions__mutmut_85': x_print_sample_tool_definitions__mutmut_85, 
    'x_print_sample_tool_definitions__mutmut_86': x_print_sample_tool_definitions__mutmut_86, 
    'x_print_sample_tool_definitions__mutmut_87': x_print_sample_tool_definitions__mutmut_87, 
    'x_print_sample_tool_definitions__mutmut_88': x_print_sample_tool_definitions__mutmut_88, 
    'x_print_sample_tool_definitions__mutmut_89': x_print_sample_tool_definitions__mutmut_89, 
    'x_print_sample_tool_definitions__mutmut_90': x_print_sample_tool_definitions__mutmut_90, 
    'x_print_sample_tool_definitions__mutmut_91': x_print_sample_tool_definitions__mutmut_91, 
    'x_print_sample_tool_definitions__mutmut_92': x_print_sample_tool_definitions__mutmut_92, 
    'x_print_sample_tool_definitions__mutmut_93': x_print_sample_tool_definitions__mutmut_93, 
    'x_print_sample_tool_definitions__mutmut_94': x_print_sample_tool_definitions__mutmut_94, 
    'x_print_sample_tool_definitions__mutmut_95': x_print_sample_tool_definitions__mutmut_95, 
    'x_print_sample_tool_definitions__mutmut_96': x_print_sample_tool_definitions__mutmut_96, 
    'x_print_sample_tool_definitions__mutmut_97': x_print_sample_tool_definitions__mutmut_97, 
    'x_print_sample_tool_definitions__mutmut_98': x_print_sample_tool_definitions__mutmut_98, 
    'x_print_sample_tool_definitions__mutmut_99': x_print_sample_tool_definitions__mutmut_99, 
    'x_print_sample_tool_definitions__mutmut_100': x_print_sample_tool_definitions__mutmut_100, 
    'x_print_sample_tool_definitions__mutmut_101': x_print_sample_tool_definitions__mutmut_101, 
    'x_print_sample_tool_definitions__mutmut_102': x_print_sample_tool_definitions__mutmut_102, 
    'x_print_sample_tool_definitions__mutmut_103': x_print_sample_tool_definitions__mutmut_103, 
    'x_print_sample_tool_definitions__mutmut_104': x_print_sample_tool_definitions__mutmut_104, 
    'x_print_sample_tool_definitions__mutmut_105': x_print_sample_tool_definitions__mutmut_105, 
    'x_print_sample_tool_definitions__mutmut_106': x_print_sample_tool_definitions__mutmut_106, 
    'x_print_sample_tool_definitions__mutmut_107': x_print_sample_tool_definitions__mutmut_107, 
    'x_print_sample_tool_definitions__mutmut_108': x_print_sample_tool_definitions__mutmut_108, 
    'x_print_sample_tool_definitions__mutmut_109': x_print_sample_tool_definitions__mutmut_109, 
    'x_print_sample_tool_definitions__mutmut_110': x_print_sample_tool_definitions__mutmut_110, 
    'x_print_sample_tool_definitions__mutmut_111': x_print_sample_tool_definitions__mutmut_111, 
    'x_print_sample_tool_definitions__mutmut_112': x_print_sample_tool_definitions__mutmut_112, 
    'x_print_sample_tool_definitions__mutmut_113': x_print_sample_tool_definitions__mutmut_113, 
    'x_print_sample_tool_definitions__mutmut_114': x_print_sample_tool_definitions__mutmut_114, 
    'x_print_sample_tool_definitions__mutmut_115': x_print_sample_tool_definitions__mutmut_115, 
    'x_print_sample_tool_definitions__mutmut_116': x_print_sample_tool_definitions__mutmut_116, 
    'x_print_sample_tool_definitions__mutmut_117': x_print_sample_tool_definitions__mutmut_117, 
    'x_print_sample_tool_definitions__mutmut_118': x_print_sample_tool_definitions__mutmut_118, 
    'x_print_sample_tool_definitions__mutmut_119': x_print_sample_tool_definitions__mutmut_119, 
    'x_print_sample_tool_definitions__mutmut_120': x_print_sample_tool_definitions__mutmut_120, 
    'x_print_sample_tool_definitions__mutmut_121': x_print_sample_tool_definitions__mutmut_121, 
    'x_print_sample_tool_definitions__mutmut_122': x_print_sample_tool_definitions__mutmut_122, 
    'x_print_sample_tool_definitions__mutmut_123': x_print_sample_tool_definitions__mutmut_123, 
    'x_print_sample_tool_definitions__mutmut_124': x_print_sample_tool_definitions__mutmut_124, 
    'x_print_sample_tool_definitions__mutmut_125': x_print_sample_tool_definitions__mutmut_125, 
    'x_print_sample_tool_definitions__mutmut_126': x_print_sample_tool_definitions__mutmut_126, 
    'x_print_sample_tool_definitions__mutmut_127': x_print_sample_tool_definitions__mutmut_127, 
    'x_print_sample_tool_definitions__mutmut_128': x_print_sample_tool_definitions__mutmut_128, 
    'x_print_sample_tool_definitions__mutmut_129': x_print_sample_tool_definitions__mutmut_129, 
    'x_print_sample_tool_definitions__mutmut_130': x_print_sample_tool_definitions__mutmut_130, 
    'x_print_sample_tool_definitions__mutmut_131': x_print_sample_tool_definitions__mutmut_131, 
    'x_print_sample_tool_definitions__mutmut_132': x_print_sample_tool_definitions__mutmut_132, 
    'x_print_sample_tool_definitions__mutmut_133': x_print_sample_tool_definitions__mutmut_133, 
    'x_print_sample_tool_definitions__mutmut_134': x_print_sample_tool_definitions__mutmut_134, 
    'x_print_sample_tool_definitions__mutmut_135': x_print_sample_tool_definitions__mutmut_135, 
    'x_print_sample_tool_definitions__mutmut_136': x_print_sample_tool_definitions__mutmut_136, 
    'x_print_sample_tool_definitions__mutmut_137': x_print_sample_tool_definitions__mutmut_137, 
    'x_print_sample_tool_definitions__mutmut_138': x_print_sample_tool_definitions__mutmut_138, 
    'x_print_sample_tool_definitions__mutmut_139': x_print_sample_tool_definitions__mutmut_139, 
    'x_print_sample_tool_definitions__mutmut_140': x_print_sample_tool_definitions__mutmut_140, 
    'x_print_sample_tool_definitions__mutmut_141': x_print_sample_tool_definitions__mutmut_141, 
    'x_print_sample_tool_definitions__mutmut_142': x_print_sample_tool_definitions__mutmut_142, 
    'x_print_sample_tool_definitions__mutmut_143': x_print_sample_tool_definitions__mutmut_143, 
    'x_print_sample_tool_definitions__mutmut_144': x_print_sample_tool_definitions__mutmut_144, 
    'x_print_sample_tool_definitions__mutmut_145': x_print_sample_tool_definitions__mutmut_145, 
    'x_print_sample_tool_definitions__mutmut_146': x_print_sample_tool_definitions__mutmut_146, 
    'x_print_sample_tool_definitions__mutmut_147': x_print_sample_tool_definitions__mutmut_147, 
    'x_print_sample_tool_definitions__mutmut_148': x_print_sample_tool_definitions__mutmut_148, 
    'x_print_sample_tool_definitions__mutmut_149': x_print_sample_tool_definitions__mutmut_149, 
    'x_print_sample_tool_definitions__mutmut_150': x_print_sample_tool_definitions__mutmut_150, 
    'x_print_sample_tool_definitions__mutmut_151': x_print_sample_tool_definitions__mutmut_151, 
    'x_print_sample_tool_definitions__mutmut_152': x_print_sample_tool_definitions__mutmut_152
}

def print_sample_tool_definitions(*args, **kwargs):
    result = _mutmut_trampoline(x_print_sample_tool_definitions__mutmut_orig, x_print_sample_tool_definitions__mutmut_mutants, args, kwargs)
    return result 

print_sample_tool_definitions.__signature__ = _mutmut_signature(x_print_sample_tool_definitions__mutmut_orig)
x_print_sample_tool_definitions__mutmut_orig.__name__ = 'x_print_sample_tool_definitions'

def x_main__mutmut_orig():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_1():
    """Main entry point."""
    # Parse command line arguments
    args = None

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_2():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = None
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_3():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "XXDEBUGXX" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_4():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "debug" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_5():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') or args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_6():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(None, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_7():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, None) and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_8():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr('debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_9():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, ) and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_10():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'XXdebugXX') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_11():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'DEBUG') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_12():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "XXINFOXX"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_13():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "info"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_14():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=None, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_15():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=None, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_16():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=None)
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_17():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_18():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_19():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  )
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_20():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') or args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_21():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(None, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_22():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, None) and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_23():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr('log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_24():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, ) and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_25():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'XXlog_fileXX') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_26():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'LOG_FILE') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_27():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=(hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_28():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') or args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_29():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(None, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_30():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, None) and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_31():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr('no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_32():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, ) and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_33():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'XXno_colorXX') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_34():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'NO_COLOR') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_35():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') and args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_36():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_37():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(None, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_38():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, None) or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_39():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr('command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_40():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, ) or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_41():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'XXcommandXX') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_42():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'COMMAND') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_43():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is not None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_44():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print(None)
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_45():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("XXNo command specified. Use --help for usage information.XX")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_46():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("no command specified. use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_47():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("NO COMMAND SPECIFIED. USE --HELP FOR USAGE INFORMATION.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_48():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command != 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_49():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'XXtoolsXX':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_50():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'TOOLS':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_51():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') or args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_52():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(None, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_53():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, None) and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_54():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr('sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_55():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, ) and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_56():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'XXsample_outputXX') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_57():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'SAMPLE_OUTPUT') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_58():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print(None)
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_59():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("XXNo tool operation specified. Use 'tools --help' for usage information.XX")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_60():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("no tool operation specified. use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_61():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("NO TOOL OPERATION SPECIFIED. USE 'TOOLS --HELP' FOR USAGE INFORMATION.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_62():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command != 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_63():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'XXrunXX':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_64():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'RUN':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_65():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info(None)
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_66():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("XXStarting LiteAgentXX")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_67():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("starting liteagent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_68():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("STARTING LITEAGENT")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_69():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') and not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_70():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_71():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(None, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_72():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, None) or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_73():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr('model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_74():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, ) or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_75():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'XXmodelXX') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_76():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'MODEL') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_77():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_78():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print(None)
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_79():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("XXError: --model argument is required for the 'run' commandXX")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_80():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_81():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("ERROR: --MODEL ARGUMENT IS REQUIRED FOR THE 'RUN' COMMAND")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_82():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print(None)
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_83():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("XXUse 'run --help' for more informationXX")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_84():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_85():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("USE 'RUN --HELP' FOR MORE INFORMATION")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_86():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(None)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_87():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(2)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_88():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(None)
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_89():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama or not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_90():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') or args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_91():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(None, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_92():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, None) and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_93():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr('ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_94():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, ) and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_95():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'XXollamaXX') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_96():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'OLLAMA') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_97():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_98():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith(None):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_99():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("XXollama/XX"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_100():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("OLLAMA/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_101():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = None
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_102():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(None)
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_103():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(None)
        return
        
    # If we get here, command wasn't recognized
    print(f"Unknown command: {args.command}. Use --help for usage information.") 

def x_main__mutmut_104():
    """Main entry point."""
    # Parse command line arguments
    args = parse_arguments()

    # Show version if requested (global flag)
    if args.version:
        show_version()
    
    # Set up logging (for all commands)
    log_level = "DEBUG" if hasattr(args, 'debug') and args.debug else "INFO"
    setup_logging(log_level=log_level, 
                  log_to_file=hasattr(args, 'log_file') and args.log_file, 
                  use_colors=not (hasattr(args, 'no_color') and args.no_color))
    
    # Load environment variables
    load_dotenv()
    
    # Process based on the command
    if not hasattr(args, 'command') or args.command is None:
        # No command specified, show help
        print("No command specified. Use --help for usage information.")
        return
        
    # Handle tools command
    if args.command == 'tools':
        if hasattr(args, 'sample_output') and args.sample_output:
            print_sample_tool_definitions()
        else:
            print("No tool operation specified. Use 'tools --help' for usage information.")
        return
            
    # Handle run command
    if args.command == 'run':
        logger.info("Starting LiteAgent")
        
        # Validate model parameter
        if not hasattr(args, 'model') or not args.model:
            print("Error: --model argument is required for the 'run' command")
            print("Use 'run --help' for more information")
            sys.exit(1)
            
        logger.info(f"Using model: {args.model}")
        
        # Debug mode handling is now done by individual providers
            
        # Automatically prepend 'ollama/' to model name if requested
        if hasattr(args, 'ollama') and args.ollama and not args.model.startswith("ollama/"):
            args.model = f"ollama/{args.model}"
            logger.info(f"Using Ollama - updated model name to: {args.model}")
        
        # Run examples
        run_examples(args)
        return
        
    # If we get here, command wasn't recognized
    print(None) 

x_main__mutmut_mutants : ClassVar[MutantDict] = {
'x_main__mutmut_1': x_main__mutmut_1, 
    'x_main__mutmut_2': x_main__mutmut_2, 
    'x_main__mutmut_3': x_main__mutmut_3, 
    'x_main__mutmut_4': x_main__mutmut_4, 
    'x_main__mutmut_5': x_main__mutmut_5, 
    'x_main__mutmut_6': x_main__mutmut_6, 
    'x_main__mutmut_7': x_main__mutmut_7, 
    'x_main__mutmut_8': x_main__mutmut_8, 
    'x_main__mutmut_9': x_main__mutmut_9, 
    'x_main__mutmut_10': x_main__mutmut_10, 
    'x_main__mutmut_11': x_main__mutmut_11, 
    'x_main__mutmut_12': x_main__mutmut_12, 
    'x_main__mutmut_13': x_main__mutmut_13, 
    'x_main__mutmut_14': x_main__mutmut_14, 
    'x_main__mutmut_15': x_main__mutmut_15, 
    'x_main__mutmut_16': x_main__mutmut_16, 
    'x_main__mutmut_17': x_main__mutmut_17, 
    'x_main__mutmut_18': x_main__mutmut_18, 
    'x_main__mutmut_19': x_main__mutmut_19, 
    'x_main__mutmut_20': x_main__mutmut_20, 
    'x_main__mutmut_21': x_main__mutmut_21, 
    'x_main__mutmut_22': x_main__mutmut_22, 
    'x_main__mutmut_23': x_main__mutmut_23, 
    'x_main__mutmut_24': x_main__mutmut_24, 
    'x_main__mutmut_25': x_main__mutmut_25, 
    'x_main__mutmut_26': x_main__mutmut_26, 
    'x_main__mutmut_27': x_main__mutmut_27, 
    'x_main__mutmut_28': x_main__mutmut_28, 
    'x_main__mutmut_29': x_main__mutmut_29, 
    'x_main__mutmut_30': x_main__mutmut_30, 
    'x_main__mutmut_31': x_main__mutmut_31, 
    'x_main__mutmut_32': x_main__mutmut_32, 
    'x_main__mutmut_33': x_main__mutmut_33, 
    'x_main__mutmut_34': x_main__mutmut_34, 
    'x_main__mutmut_35': x_main__mutmut_35, 
    'x_main__mutmut_36': x_main__mutmut_36, 
    'x_main__mutmut_37': x_main__mutmut_37, 
    'x_main__mutmut_38': x_main__mutmut_38, 
    'x_main__mutmut_39': x_main__mutmut_39, 
    'x_main__mutmut_40': x_main__mutmut_40, 
    'x_main__mutmut_41': x_main__mutmut_41, 
    'x_main__mutmut_42': x_main__mutmut_42, 
    'x_main__mutmut_43': x_main__mutmut_43, 
    'x_main__mutmut_44': x_main__mutmut_44, 
    'x_main__mutmut_45': x_main__mutmut_45, 
    'x_main__mutmut_46': x_main__mutmut_46, 
    'x_main__mutmut_47': x_main__mutmut_47, 
    'x_main__mutmut_48': x_main__mutmut_48, 
    'x_main__mutmut_49': x_main__mutmut_49, 
    'x_main__mutmut_50': x_main__mutmut_50, 
    'x_main__mutmut_51': x_main__mutmut_51, 
    'x_main__mutmut_52': x_main__mutmut_52, 
    'x_main__mutmut_53': x_main__mutmut_53, 
    'x_main__mutmut_54': x_main__mutmut_54, 
    'x_main__mutmut_55': x_main__mutmut_55, 
    'x_main__mutmut_56': x_main__mutmut_56, 
    'x_main__mutmut_57': x_main__mutmut_57, 
    'x_main__mutmut_58': x_main__mutmut_58, 
    'x_main__mutmut_59': x_main__mutmut_59, 
    'x_main__mutmut_60': x_main__mutmut_60, 
    'x_main__mutmut_61': x_main__mutmut_61, 
    'x_main__mutmut_62': x_main__mutmut_62, 
    'x_main__mutmut_63': x_main__mutmut_63, 
    'x_main__mutmut_64': x_main__mutmut_64, 
    'x_main__mutmut_65': x_main__mutmut_65, 
    'x_main__mutmut_66': x_main__mutmut_66, 
    'x_main__mutmut_67': x_main__mutmut_67, 
    'x_main__mutmut_68': x_main__mutmut_68, 
    'x_main__mutmut_69': x_main__mutmut_69, 
    'x_main__mutmut_70': x_main__mutmut_70, 
    'x_main__mutmut_71': x_main__mutmut_71, 
    'x_main__mutmut_72': x_main__mutmut_72, 
    'x_main__mutmut_73': x_main__mutmut_73, 
    'x_main__mutmut_74': x_main__mutmut_74, 
    'x_main__mutmut_75': x_main__mutmut_75, 
    'x_main__mutmut_76': x_main__mutmut_76, 
    'x_main__mutmut_77': x_main__mutmut_77, 
    'x_main__mutmut_78': x_main__mutmut_78, 
    'x_main__mutmut_79': x_main__mutmut_79, 
    'x_main__mutmut_80': x_main__mutmut_80, 
    'x_main__mutmut_81': x_main__mutmut_81, 
    'x_main__mutmut_82': x_main__mutmut_82, 
    'x_main__mutmut_83': x_main__mutmut_83, 
    'x_main__mutmut_84': x_main__mutmut_84, 
    'x_main__mutmut_85': x_main__mutmut_85, 
    'x_main__mutmut_86': x_main__mutmut_86, 
    'x_main__mutmut_87': x_main__mutmut_87, 
    'x_main__mutmut_88': x_main__mutmut_88, 
    'x_main__mutmut_89': x_main__mutmut_89, 
    'x_main__mutmut_90': x_main__mutmut_90, 
    'x_main__mutmut_91': x_main__mutmut_91, 
    'x_main__mutmut_92': x_main__mutmut_92, 
    'x_main__mutmut_93': x_main__mutmut_93, 
    'x_main__mutmut_94': x_main__mutmut_94, 
    'x_main__mutmut_95': x_main__mutmut_95, 
    'x_main__mutmut_96': x_main__mutmut_96, 
    'x_main__mutmut_97': x_main__mutmut_97, 
    'x_main__mutmut_98': x_main__mutmut_98, 
    'x_main__mutmut_99': x_main__mutmut_99, 
    'x_main__mutmut_100': x_main__mutmut_100, 
    'x_main__mutmut_101': x_main__mutmut_101, 
    'x_main__mutmut_102': x_main__mutmut_102, 
    'x_main__mutmut_103': x_main__mutmut_103, 
    'x_main__mutmut_104': x_main__mutmut_104
}

def main(*args, **kwargs):
    result = _mutmut_trampoline(x_main__mutmut_orig, x_main__mutmut_mutants, args, kwargs)
    return result 

main.__signature__ = _mutmut_signature(x_main__mutmut_orig)
x_main__mutmut_orig.__name__ = 'x_main'