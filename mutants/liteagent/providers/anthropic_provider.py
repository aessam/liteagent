"""
Anthropic provider implementation for LiteAgent.

This provider uses the official Anthropic Python client library.
"""

import os
import time
from typing import Any, Dict, List, Optional

try:
    from anthropic import Anthropic
    from anthropic.types import Message, ContentBlock, TextBlock, ToolUseBlock
except ImportError:
    raise ImportError("Anthropic library not installed. Install with: pip install anthropic")

from .base import ProviderInterface, ProviderResponse, ToolCall
from ..utils import logger
from inspect import signature as _mutmut_signature
from typing import Annotated
from typing import Callable
from typing import ClassVar


MutantDict = Annotated[dict[str, Callable], "Mutant"]


def _mutmut_trampoline(orig, mutants, call_args, call_kwargs, self_arg = None):
    """Forward call to original or mutated function, depending on the environment"""
    import os
    mutant_under_test = os.environ['MUTANT_UNDER_TEST']
    if mutant_under_test == 'fail':
        from mutmut.__main__ import MutmutProgrammaticFailException
        raise MutmutProgrammaticFailException('Failed programmatically')      
    elif mutant_under_test == 'stats':
        from mutmut.__main__ import record_trampoline_hit
        record_trampoline_hit(orig.__module__ + '.' + orig.__name__)
        result = orig(*call_args, **call_kwargs)
        return result
    prefix = orig.__module__ + '.' + orig.__name__ + '__mutmut_'
    if not mutant_under_test.startswith(prefix):
        result = orig(*call_args, **call_kwargs)
        return result
    mutant_name = mutant_under_test.rpartition('.')[-1]
    if self_arg:
        # call to a class method where self is not bound
        result = mutants[mutant_name](self_arg, *call_args, **call_kwargs)
    else:
        result = mutants[mutant_name](*call_args, **call_kwargs)
    return result


class AnthropicProvider(ProviderInterface):
    """Anthropic provider using the official Anthropic client library."""
    
    def xǁAnthropicProviderǁ__init____mutmut_orig(self, model_name: str, api_key: Optional[str] = None, **kwargs):
        """
        Initialize Anthropic provider.
        
        Args:
            model_name: Name of the Anthropic model (e.g., 'claude-3-5-sonnet-20241022')
            api_key: Anthropic API key (will use ANTHROPIC_API_KEY env var if not provided)
            **kwargs: Additional configuration
                - max_retries: Maximum number of retries
                - timeout: Request timeout in seconds
        """
        self.max_retries = kwargs.get('max_retries', 3)
        self.timeout = kwargs.get('timeout', 60)
        
        super().__init__(model_name, api_key, **kwargs)
        
    
    def xǁAnthropicProviderǁ__init____mutmut_1(self, model_name: str, api_key: Optional[str] = None, **kwargs):
        """
        Initialize Anthropic provider.
        
        Args:
            model_name: Name of the Anthropic model (e.g., 'claude-3-5-sonnet-20241022')
            api_key: Anthropic API key (will use ANTHROPIC_API_KEY env var if not provided)
            **kwargs: Additional configuration
                - max_retries: Maximum number of retries
                - timeout: Request timeout in seconds
        """
        self.max_retries = None
        self.timeout = kwargs.get('timeout', 60)
        
        super().__init__(model_name, api_key, **kwargs)
        
    
    def xǁAnthropicProviderǁ__init____mutmut_2(self, model_name: str, api_key: Optional[str] = None, **kwargs):
        """
        Initialize Anthropic provider.
        
        Args:
            model_name: Name of the Anthropic model (e.g., 'claude-3-5-sonnet-20241022')
            api_key: Anthropic API key (will use ANTHROPIC_API_KEY env var if not provided)
            **kwargs: Additional configuration
                - max_retries: Maximum number of retries
                - timeout: Request timeout in seconds
        """
        self.max_retries = kwargs.get(None, 3)
        self.timeout = kwargs.get('timeout', 60)
        
        super().__init__(model_name, api_key, **kwargs)
        
    
    def xǁAnthropicProviderǁ__init____mutmut_3(self, model_name: str, api_key: Optional[str] = None, **kwargs):
        """
        Initialize Anthropic provider.
        
        Args:
            model_name: Name of the Anthropic model (e.g., 'claude-3-5-sonnet-20241022')
            api_key: Anthropic API key (will use ANTHROPIC_API_KEY env var if not provided)
            **kwargs: Additional configuration
                - max_retries: Maximum number of retries
                - timeout: Request timeout in seconds
        """
        self.max_retries = kwargs.get('max_retries', None)
        self.timeout = kwargs.get('timeout', 60)
        
        super().__init__(model_name, api_key, **kwargs)
        
    
    def xǁAnthropicProviderǁ__init____mutmut_4(self, model_name: str, api_key: Optional[str] = None, **kwargs):
        """
        Initialize Anthropic provider.
        
        Args:
            model_name: Name of the Anthropic model (e.g., 'claude-3-5-sonnet-20241022')
            api_key: Anthropic API key (will use ANTHROPIC_API_KEY env var if not provided)
            **kwargs: Additional configuration
                - max_retries: Maximum number of retries
                - timeout: Request timeout in seconds
        """
        self.max_retries = kwargs.get(3)
        self.timeout = kwargs.get('timeout', 60)
        
        super().__init__(model_name, api_key, **kwargs)
        
    
    def xǁAnthropicProviderǁ__init____mutmut_5(self, model_name: str, api_key: Optional[str] = None, **kwargs):
        """
        Initialize Anthropic provider.
        
        Args:
            model_name: Name of the Anthropic model (e.g., 'claude-3-5-sonnet-20241022')
            api_key: Anthropic API key (will use ANTHROPIC_API_KEY env var if not provided)
            **kwargs: Additional configuration
                - max_retries: Maximum number of retries
                - timeout: Request timeout in seconds
        """
        self.max_retries = kwargs.get('max_retries', )
        self.timeout = kwargs.get('timeout', 60)
        
        super().__init__(model_name, api_key, **kwargs)
        
    
    def xǁAnthropicProviderǁ__init____mutmut_6(self, model_name: str, api_key: Optional[str] = None, **kwargs):
        """
        Initialize Anthropic provider.
        
        Args:
            model_name: Name of the Anthropic model (e.g., 'claude-3-5-sonnet-20241022')
            api_key: Anthropic API key (will use ANTHROPIC_API_KEY env var if not provided)
            **kwargs: Additional configuration
                - max_retries: Maximum number of retries
                - timeout: Request timeout in seconds
        """
        self.max_retries = kwargs.get('XXmax_retriesXX', 3)
        self.timeout = kwargs.get('timeout', 60)
        
        super().__init__(model_name, api_key, **kwargs)
        
    
    def xǁAnthropicProviderǁ__init____mutmut_7(self, model_name: str, api_key: Optional[str] = None, **kwargs):
        """
        Initialize Anthropic provider.
        
        Args:
            model_name: Name of the Anthropic model (e.g., 'claude-3-5-sonnet-20241022')
            api_key: Anthropic API key (will use ANTHROPIC_API_KEY env var if not provided)
            **kwargs: Additional configuration
                - max_retries: Maximum number of retries
                - timeout: Request timeout in seconds
        """
        self.max_retries = kwargs.get('MAX_RETRIES', 3)
        self.timeout = kwargs.get('timeout', 60)
        
        super().__init__(model_name, api_key, **kwargs)
        
    
    def xǁAnthropicProviderǁ__init____mutmut_8(self, model_name: str, api_key: Optional[str] = None, **kwargs):
        """
        Initialize Anthropic provider.
        
        Args:
            model_name: Name of the Anthropic model (e.g., 'claude-3-5-sonnet-20241022')
            api_key: Anthropic API key (will use ANTHROPIC_API_KEY env var if not provided)
            **kwargs: Additional configuration
                - max_retries: Maximum number of retries
                - timeout: Request timeout in seconds
        """
        self.max_retries = kwargs.get('max_retries', 4)
        self.timeout = kwargs.get('timeout', 60)
        
        super().__init__(model_name, api_key, **kwargs)
        
    
    def xǁAnthropicProviderǁ__init____mutmut_9(self, model_name: str, api_key: Optional[str] = None, **kwargs):
        """
        Initialize Anthropic provider.
        
        Args:
            model_name: Name of the Anthropic model (e.g., 'claude-3-5-sonnet-20241022')
            api_key: Anthropic API key (will use ANTHROPIC_API_KEY env var if not provided)
            **kwargs: Additional configuration
                - max_retries: Maximum number of retries
                - timeout: Request timeout in seconds
        """
        self.max_retries = kwargs.get('max_retries', 3)
        self.timeout = None
        
        super().__init__(model_name, api_key, **kwargs)
        
    
    def xǁAnthropicProviderǁ__init____mutmut_10(self, model_name: str, api_key: Optional[str] = None, **kwargs):
        """
        Initialize Anthropic provider.
        
        Args:
            model_name: Name of the Anthropic model (e.g., 'claude-3-5-sonnet-20241022')
            api_key: Anthropic API key (will use ANTHROPIC_API_KEY env var if not provided)
            **kwargs: Additional configuration
                - max_retries: Maximum number of retries
                - timeout: Request timeout in seconds
        """
        self.max_retries = kwargs.get('max_retries', 3)
        self.timeout = kwargs.get(None, 60)
        
        super().__init__(model_name, api_key, **kwargs)
        
    
    def xǁAnthropicProviderǁ__init____mutmut_11(self, model_name: str, api_key: Optional[str] = None, **kwargs):
        """
        Initialize Anthropic provider.
        
        Args:
            model_name: Name of the Anthropic model (e.g., 'claude-3-5-sonnet-20241022')
            api_key: Anthropic API key (will use ANTHROPIC_API_KEY env var if not provided)
            **kwargs: Additional configuration
                - max_retries: Maximum number of retries
                - timeout: Request timeout in seconds
        """
        self.max_retries = kwargs.get('max_retries', 3)
        self.timeout = kwargs.get('timeout', None)
        
        super().__init__(model_name, api_key, **kwargs)
        
    
    def xǁAnthropicProviderǁ__init____mutmut_12(self, model_name: str, api_key: Optional[str] = None, **kwargs):
        """
        Initialize Anthropic provider.
        
        Args:
            model_name: Name of the Anthropic model (e.g., 'claude-3-5-sonnet-20241022')
            api_key: Anthropic API key (will use ANTHROPIC_API_KEY env var if not provided)
            **kwargs: Additional configuration
                - max_retries: Maximum number of retries
                - timeout: Request timeout in seconds
        """
        self.max_retries = kwargs.get('max_retries', 3)
        self.timeout = kwargs.get(60)
        
        super().__init__(model_name, api_key, **kwargs)
        
    
    def xǁAnthropicProviderǁ__init____mutmut_13(self, model_name: str, api_key: Optional[str] = None, **kwargs):
        """
        Initialize Anthropic provider.
        
        Args:
            model_name: Name of the Anthropic model (e.g., 'claude-3-5-sonnet-20241022')
            api_key: Anthropic API key (will use ANTHROPIC_API_KEY env var if not provided)
            **kwargs: Additional configuration
                - max_retries: Maximum number of retries
                - timeout: Request timeout in seconds
        """
        self.max_retries = kwargs.get('max_retries', 3)
        self.timeout = kwargs.get('timeout', )
        
        super().__init__(model_name, api_key, **kwargs)
        
    
    def xǁAnthropicProviderǁ__init____mutmut_14(self, model_name: str, api_key: Optional[str] = None, **kwargs):
        """
        Initialize Anthropic provider.
        
        Args:
            model_name: Name of the Anthropic model (e.g., 'claude-3-5-sonnet-20241022')
            api_key: Anthropic API key (will use ANTHROPIC_API_KEY env var if not provided)
            **kwargs: Additional configuration
                - max_retries: Maximum number of retries
                - timeout: Request timeout in seconds
        """
        self.max_retries = kwargs.get('max_retries', 3)
        self.timeout = kwargs.get('XXtimeoutXX', 60)
        
        super().__init__(model_name, api_key, **kwargs)
        
    
    def xǁAnthropicProviderǁ__init____mutmut_15(self, model_name: str, api_key: Optional[str] = None, **kwargs):
        """
        Initialize Anthropic provider.
        
        Args:
            model_name: Name of the Anthropic model (e.g., 'claude-3-5-sonnet-20241022')
            api_key: Anthropic API key (will use ANTHROPIC_API_KEY env var if not provided)
            **kwargs: Additional configuration
                - max_retries: Maximum number of retries
                - timeout: Request timeout in seconds
        """
        self.max_retries = kwargs.get('max_retries', 3)
        self.timeout = kwargs.get('TIMEOUT', 60)
        
        super().__init__(model_name, api_key, **kwargs)
        
    
    def xǁAnthropicProviderǁ__init____mutmut_16(self, model_name: str, api_key: Optional[str] = None, **kwargs):
        """
        Initialize Anthropic provider.
        
        Args:
            model_name: Name of the Anthropic model (e.g., 'claude-3-5-sonnet-20241022')
            api_key: Anthropic API key (will use ANTHROPIC_API_KEY env var if not provided)
            **kwargs: Additional configuration
                - max_retries: Maximum number of retries
                - timeout: Request timeout in seconds
        """
        self.max_retries = kwargs.get('max_retries', 3)
        self.timeout = kwargs.get('timeout', 61)
        
        super().__init__(model_name, api_key, **kwargs)
        
    
    def xǁAnthropicProviderǁ__init____mutmut_17(self, model_name: str, api_key: Optional[str] = None, **kwargs):
        """
        Initialize Anthropic provider.
        
        Args:
            model_name: Name of the Anthropic model (e.g., 'claude-3-5-sonnet-20241022')
            api_key: Anthropic API key (will use ANTHROPIC_API_KEY env var if not provided)
            **kwargs: Additional configuration
                - max_retries: Maximum number of retries
                - timeout: Request timeout in seconds
        """
        self.max_retries = kwargs.get('max_retries', 3)
        self.timeout = kwargs.get('timeout', 60)
        
        super().__init__(None, api_key, **kwargs)
        
    
    def xǁAnthropicProviderǁ__init____mutmut_18(self, model_name: str, api_key: Optional[str] = None, **kwargs):
        """
        Initialize Anthropic provider.
        
        Args:
            model_name: Name of the Anthropic model (e.g., 'claude-3-5-sonnet-20241022')
            api_key: Anthropic API key (will use ANTHROPIC_API_KEY env var if not provided)
            **kwargs: Additional configuration
                - max_retries: Maximum number of retries
                - timeout: Request timeout in seconds
        """
        self.max_retries = kwargs.get('max_retries', 3)
        self.timeout = kwargs.get('timeout', 60)
        
        super().__init__(model_name, None, **kwargs)
        
    
    def xǁAnthropicProviderǁ__init____mutmut_19(self, model_name: str, api_key: Optional[str] = None, **kwargs):
        """
        Initialize Anthropic provider.
        
        Args:
            model_name: Name of the Anthropic model (e.g., 'claude-3-5-sonnet-20241022')
            api_key: Anthropic API key (will use ANTHROPIC_API_KEY env var if not provided)
            **kwargs: Additional configuration
                - max_retries: Maximum number of retries
                - timeout: Request timeout in seconds
        """
        self.max_retries = kwargs.get('max_retries', 3)
        self.timeout = kwargs.get('timeout', 60)
        
        super().__init__(api_key, **kwargs)
        
    
    def xǁAnthropicProviderǁ__init____mutmut_20(self, model_name: str, api_key: Optional[str] = None, **kwargs):
        """
        Initialize Anthropic provider.
        
        Args:
            model_name: Name of the Anthropic model (e.g., 'claude-3-5-sonnet-20241022')
            api_key: Anthropic API key (will use ANTHROPIC_API_KEY env var if not provided)
            **kwargs: Additional configuration
                - max_retries: Maximum number of retries
                - timeout: Request timeout in seconds
        """
        self.max_retries = kwargs.get('max_retries', 3)
        self.timeout = kwargs.get('timeout', 60)
        
        super().__init__(model_name, **kwargs)
        
    
    def xǁAnthropicProviderǁ__init____mutmut_21(self, model_name: str, api_key: Optional[str] = None, **kwargs):
        """
        Initialize Anthropic provider.
        
        Args:
            model_name: Name of the Anthropic model (e.g., 'claude-3-5-sonnet-20241022')
            api_key: Anthropic API key (will use ANTHROPIC_API_KEY env var if not provided)
            **kwargs: Additional configuration
                - max_retries: Maximum number of retries
                - timeout: Request timeout in seconds
        """
        self.max_retries = kwargs.get('max_retries', 3)
        self.timeout = kwargs.get('timeout', 60)
        
        super().__init__(model_name, api_key, )
        
    
    xǁAnthropicProviderǁ__init____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁAnthropicProviderǁ__init____mutmut_1': xǁAnthropicProviderǁ__init____mutmut_1, 
        'xǁAnthropicProviderǁ__init____mutmut_2': xǁAnthropicProviderǁ__init____mutmut_2, 
        'xǁAnthropicProviderǁ__init____mutmut_3': xǁAnthropicProviderǁ__init____mutmut_3, 
        'xǁAnthropicProviderǁ__init____mutmut_4': xǁAnthropicProviderǁ__init____mutmut_4, 
        'xǁAnthropicProviderǁ__init____mutmut_5': xǁAnthropicProviderǁ__init____mutmut_5, 
        'xǁAnthropicProviderǁ__init____mutmut_6': xǁAnthropicProviderǁ__init____mutmut_6, 
        'xǁAnthropicProviderǁ__init____mutmut_7': xǁAnthropicProviderǁ__init____mutmut_7, 
        'xǁAnthropicProviderǁ__init____mutmut_8': xǁAnthropicProviderǁ__init____mutmut_8, 
        'xǁAnthropicProviderǁ__init____mutmut_9': xǁAnthropicProviderǁ__init____mutmut_9, 
        'xǁAnthropicProviderǁ__init____mutmut_10': xǁAnthropicProviderǁ__init____mutmut_10, 
        'xǁAnthropicProviderǁ__init____mutmut_11': xǁAnthropicProviderǁ__init____mutmut_11, 
        'xǁAnthropicProviderǁ__init____mutmut_12': xǁAnthropicProviderǁ__init____mutmut_12, 
        'xǁAnthropicProviderǁ__init____mutmut_13': xǁAnthropicProviderǁ__init____mutmut_13, 
        'xǁAnthropicProviderǁ__init____mutmut_14': xǁAnthropicProviderǁ__init____mutmut_14, 
        'xǁAnthropicProviderǁ__init____mutmut_15': xǁAnthropicProviderǁ__init____mutmut_15, 
        'xǁAnthropicProviderǁ__init____mutmut_16': xǁAnthropicProviderǁ__init____mutmut_16, 
        'xǁAnthropicProviderǁ__init____mutmut_17': xǁAnthropicProviderǁ__init____mutmut_17, 
        'xǁAnthropicProviderǁ__init____mutmut_18': xǁAnthropicProviderǁ__init____mutmut_18, 
        'xǁAnthropicProviderǁ__init____mutmut_19': xǁAnthropicProviderǁ__init____mutmut_19, 
        'xǁAnthropicProviderǁ__init____mutmut_20': xǁAnthropicProviderǁ__init____mutmut_20, 
        'xǁAnthropicProviderǁ__init____mutmut_21': xǁAnthropicProviderǁ__init____mutmut_21
    }
    
    def __init__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁAnthropicProviderǁ__init____mutmut_orig"), object.__getattribute__(self, "xǁAnthropicProviderǁ__init____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __init__.__signature__ = _mutmut_signature(xǁAnthropicProviderǁ__init____mutmut_orig)
    xǁAnthropicProviderǁ__init____mutmut_orig.__name__ = 'xǁAnthropicProviderǁ__init__'
    def xǁAnthropicProviderǁ_get_provider_name__mutmut_orig(self) -> str:
        """Return the provider name."""
        return 'anthropic'
        
    def xǁAnthropicProviderǁ_get_provider_name__mutmut_1(self) -> str:
        """Return the provider name."""
        return 'XXanthropicXX'
        
    def xǁAnthropicProviderǁ_get_provider_name__mutmut_2(self) -> str:
        """Return the provider name."""
        return 'ANTHROPIC'
        
    
    xǁAnthropicProviderǁ_get_provider_name__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁAnthropicProviderǁ_get_provider_name__mutmut_1': xǁAnthropicProviderǁ_get_provider_name__mutmut_1, 
        'xǁAnthropicProviderǁ_get_provider_name__mutmut_2': xǁAnthropicProviderǁ_get_provider_name__mutmut_2
    }
    
    def _get_provider_name(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁAnthropicProviderǁ_get_provider_name__mutmut_orig"), object.__getattribute__(self, "xǁAnthropicProviderǁ_get_provider_name__mutmut_mutants"), args, kwargs, self)
        return result 
    
    _get_provider_name.__signature__ = _mutmut_signature(xǁAnthropicProviderǁ_get_provider_name__mutmut_orig)
    xǁAnthropicProviderǁ_get_provider_name__mutmut_orig.__name__ = 'xǁAnthropicProviderǁ_get_provider_name'
    def xǁAnthropicProviderǁ_setup_client__mutmut_orig(self) -> None:
        """Setup the Anthropic client."""
        self.client = Anthropic(
            api_key=self.api_key or os.getenv('ANTHROPIC_API_KEY'),
            max_retries=self.max_retries,
            timeout=self.timeout,
        )
        
    def xǁAnthropicProviderǁ_setup_client__mutmut_1(self) -> None:
        """Setup the Anthropic client."""
        self.client = None
        
    def xǁAnthropicProviderǁ_setup_client__mutmut_2(self) -> None:
        """Setup the Anthropic client."""
        self.client = Anthropic(
            api_key=None,
            max_retries=self.max_retries,
            timeout=self.timeout,
        )
        
    def xǁAnthropicProviderǁ_setup_client__mutmut_3(self) -> None:
        """Setup the Anthropic client."""
        self.client = Anthropic(
            api_key=self.api_key or os.getenv('ANTHROPIC_API_KEY'),
            max_retries=None,
            timeout=self.timeout,
        )
        
    def xǁAnthropicProviderǁ_setup_client__mutmut_4(self) -> None:
        """Setup the Anthropic client."""
        self.client = Anthropic(
            api_key=self.api_key or os.getenv('ANTHROPIC_API_KEY'),
            max_retries=self.max_retries,
            timeout=None,
        )
        
    def xǁAnthropicProviderǁ_setup_client__mutmut_5(self) -> None:
        """Setup the Anthropic client."""
        self.client = Anthropic(
            max_retries=self.max_retries,
            timeout=self.timeout,
        )
        
    def xǁAnthropicProviderǁ_setup_client__mutmut_6(self) -> None:
        """Setup the Anthropic client."""
        self.client = Anthropic(
            api_key=self.api_key or os.getenv('ANTHROPIC_API_KEY'),
            timeout=self.timeout,
        )
        
    def xǁAnthropicProviderǁ_setup_client__mutmut_7(self) -> None:
        """Setup the Anthropic client."""
        self.client = Anthropic(
            api_key=self.api_key or os.getenv('ANTHROPIC_API_KEY'),
            max_retries=self.max_retries,
            )
        
    def xǁAnthropicProviderǁ_setup_client__mutmut_8(self) -> None:
        """Setup the Anthropic client."""
        self.client = Anthropic(
            api_key=self.api_key and os.getenv('ANTHROPIC_API_KEY'),
            max_retries=self.max_retries,
            timeout=self.timeout,
        )
        
    def xǁAnthropicProviderǁ_setup_client__mutmut_9(self) -> None:
        """Setup the Anthropic client."""
        self.client = Anthropic(
            api_key=self.api_key or os.getenv(None),
            max_retries=self.max_retries,
            timeout=self.timeout,
        )
        
    def xǁAnthropicProviderǁ_setup_client__mutmut_10(self) -> None:
        """Setup the Anthropic client."""
        self.client = Anthropic(
            api_key=self.api_key or os.getenv('XXANTHROPIC_API_KEYXX'),
            max_retries=self.max_retries,
            timeout=self.timeout,
        )
        
    def xǁAnthropicProviderǁ_setup_client__mutmut_11(self) -> None:
        """Setup the Anthropic client."""
        self.client = Anthropic(
            api_key=self.api_key or os.getenv('anthropic_api_key'),
            max_retries=self.max_retries,
            timeout=self.timeout,
        )
        
    
    xǁAnthropicProviderǁ_setup_client__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁAnthropicProviderǁ_setup_client__mutmut_1': xǁAnthropicProviderǁ_setup_client__mutmut_1, 
        'xǁAnthropicProviderǁ_setup_client__mutmut_2': xǁAnthropicProviderǁ_setup_client__mutmut_2, 
        'xǁAnthropicProviderǁ_setup_client__mutmut_3': xǁAnthropicProviderǁ_setup_client__mutmut_3, 
        'xǁAnthropicProviderǁ_setup_client__mutmut_4': xǁAnthropicProviderǁ_setup_client__mutmut_4, 
        'xǁAnthropicProviderǁ_setup_client__mutmut_5': xǁAnthropicProviderǁ_setup_client__mutmut_5, 
        'xǁAnthropicProviderǁ_setup_client__mutmut_6': xǁAnthropicProviderǁ_setup_client__mutmut_6, 
        'xǁAnthropicProviderǁ_setup_client__mutmut_7': xǁAnthropicProviderǁ_setup_client__mutmut_7, 
        'xǁAnthropicProviderǁ_setup_client__mutmut_8': xǁAnthropicProviderǁ_setup_client__mutmut_8, 
        'xǁAnthropicProviderǁ_setup_client__mutmut_9': xǁAnthropicProviderǁ_setup_client__mutmut_9, 
        'xǁAnthropicProviderǁ_setup_client__mutmut_10': xǁAnthropicProviderǁ_setup_client__mutmut_10, 
        'xǁAnthropicProviderǁ_setup_client__mutmut_11': xǁAnthropicProviderǁ_setup_client__mutmut_11
    }
    
    def _setup_client(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁAnthropicProviderǁ_setup_client__mutmut_orig"), object.__getattribute__(self, "xǁAnthropicProviderǁ_setup_client__mutmut_mutants"), args, kwargs, self)
        return result 
    
    _setup_client.__signature__ = _mutmut_signature(xǁAnthropicProviderǁ_setup_client__mutmut_orig)
    xǁAnthropicProviderǁ_setup_client__mutmut_orig.__name__ = 'xǁAnthropicProviderǁ_setup_client'
    def xǁAnthropicProviderǁgenerate_response__mutmut_orig(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_1(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = None
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_2(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(None, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_3(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, None)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_4(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_5(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, )
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_6(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = None
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_7(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(None)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_8(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = ""
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_9(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages or anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_10(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get(None) == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_11(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[1].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_12(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('XXroleXX') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_13(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('ROLE') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_14(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') != 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_15(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'XXsystemXX':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_16(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'SYSTEM':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_17(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = None
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_18(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(None)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_19(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(1)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_20(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['XXcontentXX']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_21(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['CONTENT']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_22(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = None
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_23(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'XXmodelXX': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_24(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'MODEL': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_25(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'XXmessagesXX': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_26(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'MESSAGES': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_27(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'XXmax_tokensXX': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_28(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'MAX_TOKENS': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_29(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get(None, 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_30(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', None),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_31(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get(4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_32(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', ),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_33(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('XXmax_tokensXX', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_34(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('MAX_TOKENS', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_35(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4097),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_36(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = None
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_37(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['XXsystemXX'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_38(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['SYSTEM'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_39(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'XXtemperatureXX' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_40(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'TEMPERATURE' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_41(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' not in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_42(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = None
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_43(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['XXtemperatureXX'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_44(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['TEMPERATURE'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_45(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['XXtemperatureXX']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_46(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['TEMPERATURE']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_47(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools or self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_48(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = None
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_49(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['XXtoolsXX'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_50(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['TOOLS'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_51(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(None)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_52(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) or self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_53(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get(None, False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_54(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', None) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_55(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get(False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_56(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', ) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_57(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('XXenable_cachingXX', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_58(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('ENABLE_CACHING', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_59(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', True) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_60(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message or len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_61(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) >= 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_62(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1001:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_63(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = None
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_64(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['XXsystemXX'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_65(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['SYSTEM'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_66(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "XXtypeXX": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_67(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "TYPE": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_68(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "XXtextXX",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_69(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "TEXT",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_70(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "XXtextXX": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_71(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "TEXT": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_72(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "XXcache_controlXX": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_73(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "CACHE_CONTROL": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_74(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"XXtypeXX": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_75(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"TYPE": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_76(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "XXephemeralXX"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_77(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "EPHEMERAL"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_78(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['XXmessagesXX']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_79(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['MESSAGES']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_80(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) or len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_81(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) >= 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_82(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1001:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_83(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = None
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_84(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['XXcontentXX'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_85(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['CONTENT'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_86(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "XXtypeXX": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_87(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "TYPE": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_88(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "XXtextXX", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_89(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "TEXT", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_90(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "XXtextXX": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_91(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "TEXT": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_92(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['XXcontentXX'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_93(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['CONTENT'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_94(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "XXcache_controlXX": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_95(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "CACHE_CONTROL": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_96(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"XXtypeXX": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_97(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"TYPE": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_98(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "XXephemeralXX"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_99(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "EPHEMERAL"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_100(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['XXcontentXX']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_101(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['CONTENT']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_102(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' or len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_103(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get(None) == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_104(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('XXtypeXX') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_105(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('TYPE') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_106(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') != 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_107(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'XXtextXX' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_108(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'TEXT' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_109(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) >= 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_110(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1001):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_111(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = None
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_112(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['XXcache_controlXX'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_113(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['CACHE_CONTROL'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_114(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"XXtypeXX": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_115(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"TYPE": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_116(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "XXephemeralXX"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_117(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "EPHEMERAL"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_118(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = None
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_119(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = None
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_120(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(None)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_121(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = None
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_122(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() + start_time
        self._log_response(provider_response, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_123(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(None, elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_124(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, None)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_125(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(elapsed_time)
        
        return provider_response
            
    def xǁAnthropicProviderǁgenerate_response__mutmut_126(
        self, 
        messages: List[Dict[str, Any]], 
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> ProviderResponse:
        """
        Generate a response using Anthropic's messages API.
        
        Args:
            messages: List of message dictionaries
            tools: Optional list of tool definitions
            **kwargs: Additional parameters like temperature, max_tokens, etc.
            
        Returns:
            ProviderResponse: Standardized response object
        """
        start_time = time.time()
        self._log_request(messages, tools)
        
        # Convert messages to Anthropic format
        anthropic_messages = self._convert_messages(messages)
        
        # Extract system message if present
        system_message = None
        if anthropic_messages and anthropic_messages[0].get('role') == 'system':
            system_message = anthropic_messages.pop(0)['content']
            
        # Prepare request parameters
        request_params = {
            'model': self.model_name,
            'messages': anthropic_messages,
            'max_tokens': kwargs.get('max_tokens', 4096),  # Required for Anthropic
        }
        
        if system_message:
            request_params['system'] = system_message
            
        # Add other optional parameters
        if 'temperature' in kwargs:
            request_params['temperature'] = kwargs['temperature']
            
        # Add tools if provided and model supports them
        if tools and self.supports_tool_calling():
            request_params['tools'] = self._convert_tools(tools)
        
        # Add caching support if enabled and model supports it
        if kwargs.get('enable_caching', False) and self.supports_caching():
            # Mark system message for caching if it's long enough
            if system_message and len(system_message) > 1000:
                request_params['system'] = [
                    {
                        "type": "text",
                        "text": system_message,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            
            # Mark long messages for caching
            for message in request_params['messages']:
                if isinstance(message.get('content'), str) and len(message['content']) > 1000:
                    message['content'] = [
                        {
                            "type": "text", 
                            "text": message['content'],
                            "cache_control": {"type": "ephemeral"}
                        }
                    ]
                elif isinstance(message.get('content'), list):
                    # For multimodal content, mark text parts for caching if long enough
                    for content_item in message['content']:
                        if (content_item.get('type') == 'text' and 
                            len(content_item.get('text', '')) > 1000):
                            content_item['cache_control'] = {"type": "ephemeral"}
            
        # Make the API call
        response: Message = self.client.messages.create(**request_params)
        
        # Convert to standardized format
        provider_response = self._convert_response(response)
        
        elapsed_time = time.time() - start_time
        self._log_response(provider_response, )
        
        return provider_response
            
    
    xǁAnthropicProviderǁgenerate_response__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁAnthropicProviderǁgenerate_response__mutmut_1': xǁAnthropicProviderǁgenerate_response__mutmut_1, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_2': xǁAnthropicProviderǁgenerate_response__mutmut_2, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_3': xǁAnthropicProviderǁgenerate_response__mutmut_3, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_4': xǁAnthropicProviderǁgenerate_response__mutmut_4, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_5': xǁAnthropicProviderǁgenerate_response__mutmut_5, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_6': xǁAnthropicProviderǁgenerate_response__mutmut_6, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_7': xǁAnthropicProviderǁgenerate_response__mutmut_7, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_8': xǁAnthropicProviderǁgenerate_response__mutmut_8, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_9': xǁAnthropicProviderǁgenerate_response__mutmut_9, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_10': xǁAnthropicProviderǁgenerate_response__mutmut_10, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_11': xǁAnthropicProviderǁgenerate_response__mutmut_11, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_12': xǁAnthropicProviderǁgenerate_response__mutmut_12, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_13': xǁAnthropicProviderǁgenerate_response__mutmut_13, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_14': xǁAnthropicProviderǁgenerate_response__mutmut_14, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_15': xǁAnthropicProviderǁgenerate_response__mutmut_15, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_16': xǁAnthropicProviderǁgenerate_response__mutmut_16, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_17': xǁAnthropicProviderǁgenerate_response__mutmut_17, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_18': xǁAnthropicProviderǁgenerate_response__mutmut_18, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_19': xǁAnthropicProviderǁgenerate_response__mutmut_19, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_20': xǁAnthropicProviderǁgenerate_response__mutmut_20, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_21': xǁAnthropicProviderǁgenerate_response__mutmut_21, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_22': xǁAnthropicProviderǁgenerate_response__mutmut_22, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_23': xǁAnthropicProviderǁgenerate_response__mutmut_23, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_24': xǁAnthropicProviderǁgenerate_response__mutmut_24, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_25': xǁAnthropicProviderǁgenerate_response__mutmut_25, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_26': xǁAnthropicProviderǁgenerate_response__mutmut_26, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_27': xǁAnthropicProviderǁgenerate_response__mutmut_27, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_28': xǁAnthropicProviderǁgenerate_response__mutmut_28, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_29': xǁAnthropicProviderǁgenerate_response__mutmut_29, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_30': xǁAnthropicProviderǁgenerate_response__mutmut_30, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_31': xǁAnthropicProviderǁgenerate_response__mutmut_31, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_32': xǁAnthropicProviderǁgenerate_response__mutmut_32, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_33': xǁAnthropicProviderǁgenerate_response__mutmut_33, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_34': xǁAnthropicProviderǁgenerate_response__mutmut_34, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_35': xǁAnthropicProviderǁgenerate_response__mutmut_35, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_36': xǁAnthropicProviderǁgenerate_response__mutmut_36, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_37': xǁAnthropicProviderǁgenerate_response__mutmut_37, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_38': xǁAnthropicProviderǁgenerate_response__mutmut_38, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_39': xǁAnthropicProviderǁgenerate_response__mutmut_39, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_40': xǁAnthropicProviderǁgenerate_response__mutmut_40, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_41': xǁAnthropicProviderǁgenerate_response__mutmut_41, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_42': xǁAnthropicProviderǁgenerate_response__mutmut_42, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_43': xǁAnthropicProviderǁgenerate_response__mutmut_43, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_44': xǁAnthropicProviderǁgenerate_response__mutmut_44, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_45': xǁAnthropicProviderǁgenerate_response__mutmut_45, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_46': xǁAnthropicProviderǁgenerate_response__mutmut_46, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_47': xǁAnthropicProviderǁgenerate_response__mutmut_47, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_48': xǁAnthropicProviderǁgenerate_response__mutmut_48, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_49': xǁAnthropicProviderǁgenerate_response__mutmut_49, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_50': xǁAnthropicProviderǁgenerate_response__mutmut_50, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_51': xǁAnthropicProviderǁgenerate_response__mutmut_51, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_52': xǁAnthropicProviderǁgenerate_response__mutmut_52, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_53': xǁAnthropicProviderǁgenerate_response__mutmut_53, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_54': xǁAnthropicProviderǁgenerate_response__mutmut_54, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_55': xǁAnthropicProviderǁgenerate_response__mutmut_55, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_56': xǁAnthropicProviderǁgenerate_response__mutmut_56, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_57': xǁAnthropicProviderǁgenerate_response__mutmut_57, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_58': xǁAnthropicProviderǁgenerate_response__mutmut_58, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_59': xǁAnthropicProviderǁgenerate_response__mutmut_59, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_60': xǁAnthropicProviderǁgenerate_response__mutmut_60, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_61': xǁAnthropicProviderǁgenerate_response__mutmut_61, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_62': xǁAnthropicProviderǁgenerate_response__mutmut_62, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_63': xǁAnthropicProviderǁgenerate_response__mutmut_63, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_64': xǁAnthropicProviderǁgenerate_response__mutmut_64, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_65': xǁAnthropicProviderǁgenerate_response__mutmut_65, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_66': xǁAnthropicProviderǁgenerate_response__mutmut_66, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_67': xǁAnthropicProviderǁgenerate_response__mutmut_67, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_68': xǁAnthropicProviderǁgenerate_response__mutmut_68, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_69': xǁAnthropicProviderǁgenerate_response__mutmut_69, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_70': xǁAnthropicProviderǁgenerate_response__mutmut_70, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_71': xǁAnthropicProviderǁgenerate_response__mutmut_71, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_72': xǁAnthropicProviderǁgenerate_response__mutmut_72, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_73': xǁAnthropicProviderǁgenerate_response__mutmut_73, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_74': xǁAnthropicProviderǁgenerate_response__mutmut_74, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_75': xǁAnthropicProviderǁgenerate_response__mutmut_75, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_76': xǁAnthropicProviderǁgenerate_response__mutmut_76, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_77': xǁAnthropicProviderǁgenerate_response__mutmut_77, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_78': xǁAnthropicProviderǁgenerate_response__mutmut_78, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_79': xǁAnthropicProviderǁgenerate_response__mutmut_79, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_80': xǁAnthropicProviderǁgenerate_response__mutmut_80, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_81': xǁAnthropicProviderǁgenerate_response__mutmut_81, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_82': xǁAnthropicProviderǁgenerate_response__mutmut_82, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_83': xǁAnthropicProviderǁgenerate_response__mutmut_83, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_84': xǁAnthropicProviderǁgenerate_response__mutmut_84, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_85': xǁAnthropicProviderǁgenerate_response__mutmut_85, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_86': xǁAnthropicProviderǁgenerate_response__mutmut_86, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_87': xǁAnthropicProviderǁgenerate_response__mutmut_87, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_88': xǁAnthropicProviderǁgenerate_response__mutmut_88, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_89': xǁAnthropicProviderǁgenerate_response__mutmut_89, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_90': xǁAnthropicProviderǁgenerate_response__mutmut_90, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_91': xǁAnthropicProviderǁgenerate_response__mutmut_91, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_92': xǁAnthropicProviderǁgenerate_response__mutmut_92, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_93': xǁAnthropicProviderǁgenerate_response__mutmut_93, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_94': xǁAnthropicProviderǁgenerate_response__mutmut_94, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_95': xǁAnthropicProviderǁgenerate_response__mutmut_95, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_96': xǁAnthropicProviderǁgenerate_response__mutmut_96, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_97': xǁAnthropicProviderǁgenerate_response__mutmut_97, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_98': xǁAnthropicProviderǁgenerate_response__mutmut_98, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_99': xǁAnthropicProviderǁgenerate_response__mutmut_99, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_100': xǁAnthropicProviderǁgenerate_response__mutmut_100, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_101': xǁAnthropicProviderǁgenerate_response__mutmut_101, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_102': xǁAnthropicProviderǁgenerate_response__mutmut_102, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_103': xǁAnthropicProviderǁgenerate_response__mutmut_103, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_104': xǁAnthropicProviderǁgenerate_response__mutmut_104, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_105': xǁAnthropicProviderǁgenerate_response__mutmut_105, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_106': xǁAnthropicProviderǁgenerate_response__mutmut_106, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_107': xǁAnthropicProviderǁgenerate_response__mutmut_107, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_108': xǁAnthropicProviderǁgenerate_response__mutmut_108, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_109': xǁAnthropicProviderǁgenerate_response__mutmut_109, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_110': xǁAnthropicProviderǁgenerate_response__mutmut_110, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_111': xǁAnthropicProviderǁgenerate_response__mutmut_111, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_112': xǁAnthropicProviderǁgenerate_response__mutmut_112, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_113': xǁAnthropicProviderǁgenerate_response__mutmut_113, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_114': xǁAnthropicProviderǁgenerate_response__mutmut_114, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_115': xǁAnthropicProviderǁgenerate_response__mutmut_115, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_116': xǁAnthropicProviderǁgenerate_response__mutmut_116, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_117': xǁAnthropicProviderǁgenerate_response__mutmut_117, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_118': xǁAnthropicProviderǁgenerate_response__mutmut_118, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_119': xǁAnthropicProviderǁgenerate_response__mutmut_119, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_120': xǁAnthropicProviderǁgenerate_response__mutmut_120, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_121': xǁAnthropicProviderǁgenerate_response__mutmut_121, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_122': xǁAnthropicProviderǁgenerate_response__mutmut_122, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_123': xǁAnthropicProviderǁgenerate_response__mutmut_123, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_124': xǁAnthropicProviderǁgenerate_response__mutmut_124, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_125': xǁAnthropicProviderǁgenerate_response__mutmut_125, 
        'xǁAnthropicProviderǁgenerate_response__mutmut_126': xǁAnthropicProviderǁgenerate_response__mutmut_126
    }
    
    def generate_response(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁAnthropicProviderǁgenerate_response__mutmut_orig"), object.__getattribute__(self, "xǁAnthropicProviderǁgenerate_response__mutmut_mutants"), args, kwargs, self)
        return result 
    
    generate_response.__signature__ = _mutmut_signature(xǁAnthropicProviderǁgenerate_response__mutmut_orig)
    xǁAnthropicProviderǁgenerate_response__mutmut_orig.__name__ = 'xǁAnthropicProviderǁgenerate_response'
    def xǁAnthropicProviderǁ_convert_messages__mutmut_orig(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_1(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = None
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_2(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = None
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_3(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['XXroleXX']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_4(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['ROLE']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_5(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = None
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_6(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['XXcontentXX']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_7(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['CONTENT']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_8(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role not in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_9(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['XXfunctionXX', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_10(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['FUNCTION', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_11(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'XXtoolXX']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_12(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'TOOL']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_13(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = None
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_14(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get(None, msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_15(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', None)
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_16(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get(msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_17(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', )
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_18(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('XXtool_call_idXX', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_19(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('TOOL_CALL_ID', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_20(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get(None, ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_21(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', None))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_22(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get(''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_23(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_24(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('XXnameXX', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_25(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('NAME', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_26(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', 'XXXX'))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_27(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append(None)
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_28(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'XXroleXX': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_29(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'ROLE': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_30(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'XXuserXX',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_31(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'USER',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_32(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'XXcontentXX': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_33(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'CONTENT': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_34(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'XXtypeXX': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_35(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'TYPE': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_36(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'XXtool_resultXX',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_37(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'TOOL_RESULT',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_38(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'XXtool_use_idXX': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_39(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'TOOL_USE_ID': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_40(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'XXcontentXX': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_41(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'CONTENT': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_42(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(None)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_43(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                break
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_44(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' or 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_45(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role != 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_46(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'XXassistantXX' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_47(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'ASSISTANT' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_48(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'XXtool_callsXX' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_49(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'TOOL_CALLS' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_50(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' not in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_51(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = None
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_52(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append(None)
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_53(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'XXtypeXX': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_54(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'TYPE': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_55(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'XXtextXX', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_56(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'TEXT', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_57(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'XXtextXX': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_58(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'TEXT': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_59(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['XXtool_callsXX']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_60(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['TOOL_CALLS']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_61(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = None
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_62(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['XXfunctionXX']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_63(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['FUNCTION']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_64(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['XXargumentsXX']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_65(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['ARGUMENTS']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_66(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = None
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_67(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(None)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_68(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(None) from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_69(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_70(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = None
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_71(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append(None)
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_72(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'XXtypeXX': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_73(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'TYPE': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_74(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'XXtool_useXX',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_75(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'TOOL_USE',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_76(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'XXidXX': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_77(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'ID': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_78(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['XXidXX'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_79(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['ID'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_80(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'XXnameXX': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_81(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'NAME': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_82(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['XXfunctionXX']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_83(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['FUNCTION']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_84(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['XXnameXX'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_85(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['NAME'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_86(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'XXinputXX': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_87(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'INPUT': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_88(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append(None)
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_89(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'XXroleXX': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_90(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'ROLE': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_91(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'XXassistantXX',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_92(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'ASSISTANT',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_93(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'XXcontentXX': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_94(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'CONTENT': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_95(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = None
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_96(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['XXtypeXX'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_97(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['TYPE'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_98(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] != 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_99(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'XXtextXX':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_100(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'TEXT':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_101(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append(None)
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_102(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'XXtypeXX': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_103(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'TYPE': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_104(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'XXtextXX',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_105(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'TEXT',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_106(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'XXtextXX': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_107(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'TEXT': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_108(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['XXtextXX']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_109(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['TEXT']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_110(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['XXtypeXX'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_111(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['TYPE'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_112(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] != 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_113(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'XXimage_urlXX':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_114(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'IMAGE_URL':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_115(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = None
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_116(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['XXimage_urlXX']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_117(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['IMAGE_URL']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_118(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['XXurlXX']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_119(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['URL']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_120(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith(None):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_121(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('XXdata:XX'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_122(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('DATA:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_123(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = None
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_124(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(None, 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_125(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', None)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_126(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_127(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', )
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_128(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.rsplit(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_129(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split('XX,XX', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_130(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 2)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_131(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) != 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_132(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 3:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_133(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = None  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_134(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[1]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_135(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = None
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_136(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[2]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_137(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = None
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_138(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace(None, '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_139(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', None)
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_140(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_141(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', )
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_142(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(None)[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_143(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split('XX;XX')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_144(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[1].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_145(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('XXdata:XX', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_146(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('DATA:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_147(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', 'XXXX')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_148(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append(None)
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_149(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'XXtypeXX': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_150(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'TYPE': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_151(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'XXimageXX',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_152(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'IMAGE',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_153(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'XXsourceXX': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_154(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'SOURCE': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_155(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'XXtypeXX': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_156(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'TYPE': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_157(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'XXbase64XX',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_158(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'BASE64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_159(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'XXmedia_typeXX': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_160(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'MEDIA_TYPE': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_161(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'XXdataXX': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_162(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'DATA': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_163(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append(None)
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_164(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'XXtypeXX': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_165(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'TYPE': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_166(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'XXtextXX',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_167(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'TEXT',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_168(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'XXtextXX': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_169(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'TEXT': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_170(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append(None)
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_171(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'XXroleXX': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_172(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'ROLE': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_173(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'XXcontentXX': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_174(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'CONTENT': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_175(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append(None)
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_176(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'XXroleXX': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_177(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'ROLE': role,
                        'content': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_178(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'XXcontentXX': content
                    })
                
        return anthropic_messages
        
    def xǁAnthropicProviderǁ_convert_messages__mutmut_179(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert messages to Anthropic format."""
        anthropic_messages = []
        
        for msg in messages:
            role = msg['role']
            content = msg['content']
            
            # Handle function/tool result messages for Anthropic  
            if role in ['function', 'tool']:
                # Convert tool result to Anthropic format
                tool_call_id = msg.get('tool_call_id', msg.get('name', ''))
                anthropic_messages.append({
                    'role': 'user',
                    'content': [
                        {
                            'type': 'tool_result',
                            'tool_use_id': tool_call_id,
                            'content': str(content)
                        }
                    ]
                })
                continue
                
            # Convert assistant messages with tool calls
            if role == 'assistant' and 'tool_calls' in msg:
                # Create content blocks for text and tool uses
                content_blocks = []
                
                if content:
                    content_blocks.append({'type': 'text', 'text': content})
                    
                for tool_call in msg['tool_calls']:
                    # Ensure arguments are a dictionary for Anthropic API
                    arguments = tool_call['function']['arguments']
                    if isinstance(arguments, str):
                        try:
                            import json
                            arguments = json.loads(arguments)
                        except json.JSONDecodeError as e:
                            raise ValueError(f"Failed to parse tool arguments as JSON: {arguments}") from e
                    elif not isinstance(arguments, dict):
                        arguments = {}
                        
                    content_blocks.append({
                        'type': 'tool_use',
                        'id': tool_call['id'],
                        'name': tool_call['function']['name'],
                        'input': arguments
                    })
                    
                anthropic_messages.append({
                    'role': 'assistant',
                    'content': content_blocks
                })
            else:
                # Handle multimodal content (text + images)
                if isinstance(content, list):
                    # Already in multimodal format - convert for Anthropic
                    anthropic_content = []
                    for item in content:
                        if item['type'] == 'text':
                            anthropic_content.append({
                                'type': 'text',
                                'text': item['text']
                            })
                        elif item['type'] == 'image_url':
                            # Convert OpenAI image format to Anthropic format
                            image_url = item['image_url']['url']
                            if image_url.startswith('data:'):
                                # Base64 encoded image
                                # Extract media type and data
                                parts = image_url.split(',', 1)
                                if len(parts) == 2:
                                    header = parts[0]  # data:image/jpeg;base64
                                    data = parts[1]
                                    # Extract media type
                                    media_type = header.split(';')[0].replace('data:', '')
                                    anthropic_content.append({
                                        'type': 'image',
                                        'source': {
                                            'type': 'base64',
                                            'media_type': media_type,
                                            'data': data
                                        }
                                    })
                            else:
                                # External URL - Anthropic doesn't support external URLs directly
                                # Add a text description instead
                                anthropic_content.append({
                                    'type': 'text',
                                    'text': f'[Image URL provided: {image_url}]'
                                })
                    
                    anthropic_messages.append({
                        'role': role,
                        'content': anthropic_content
                    })
                else:
                    # Simple text content
                    anthropic_messages.append({
                        'role': role,
                        'CONTENT': content
                    })
                
        return anthropic_messages
        
    
    xǁAnthropicProviderǁ_convert_messages__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁAnthropicProviderǁ_convert_messages__mutmut_1': xǁAnthropicProviderǁ_convert_messages__mutmut_1, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_2': xǁAnthropicProviderǁ_convert_messages__mutmut_2, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_3': xǁAnthropicProviderǁ_convert_messages__mutmut_3, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_4': xǁAnthropicProviderǁ_convert_messages__mutmut_4, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_5': xǁAnthropicProviderǁ_convert_messages__mutmut_5, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_6': xǁAnthropicProviderǁ_convert_messages__mutmut_6, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_7': xǁAnthropicProviderǁ_convert_messages__mutmut_7, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_8': xǁAnthropicProviderǁ_convert_messages__mutmut_8, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_9': xǁAnthropicProviderǁ_convert_messages__mutmut_9, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_10': xǁAnthropicProviderǁ_convert_messages__mutmut_10, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_11': xǁAnthropicProviderǁ_convert_messages__mutmut_11, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_12': xǁAnthropicProviderǁ_convert_messages__mutmut_12, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_13': xǁAnthropicProviderǁ_convert_messages__mutmut_13, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_14': xǁAnthropicProviderǁ_convert_messages__mutmut_14, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_15': xǁAnthropicProviderǁ_convert_messages__mutmut_15, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_16': xǁAnthropicProviderǁ_convert_messages__mutmut_16, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_17': xǁAnthropicProviderǁ_convert_messages__mutmut_17, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_18': xǁAnthropicProviderǁ_convert_messages__mutmut_18, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_19': xǁAnthropicProviderǁ_convert_messages__mutmut_19, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_20': xǁAnthropicProviderǁ_convert_messages__mutmut_20, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_21': xǁAnthropicProviderǁ_convert_messages__mutmut_21, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_22': xǁAnthropicProviderǁ_convert_messages__mutmut_22, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_23': xǁAnthropicProviderǁ_convert_messages__mutmut_23, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_24': xǁAnthropicProviderǁ_convert_messages__mutmut_24, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_25': xǁAnthropicProviderǁ_convert_messages__mutmut_25, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_26': xǁAnthropicProviderǁ_convert_messages__mutmut_26, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_27': xǁAnthropicProviderǁ_convert_messages__mutmut_27, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_28': xǁAnthropicProviderǁ_convert_messages__mutmut_28, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_29': xǁAnthropicProviderǁ_convert_messages__mutmut_29, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_30': xǁAnthropicProviderǁ_convert_messages__mutmut_30, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_31': xǁAnthropicProviderǁ_convert_messages__mutmut_31, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_32': xǁAnthropicProviderǁ_convert_messages__mutmut_32, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_33': xǁAnthropicProviderǁ_convert_messages__mutmut_33, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_34': xǁAnthropicProviderǁ_convert_messages__mutmut_34, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_35': xǁAnthropicProviderǁ_convert_messages__mutmut_35, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_36': xǁAnthropicProviderǁ_convert_messages__mutmut_36, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_37': xǁAnthropicProviderǁ_convert_messages__mutmut_37, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_38': xǁAnthropicProviderǁ_convert_messages__mutmut_38, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_39': xǁAnthropicProviderǁ_convert_messages__mutmut_39, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_40': xǁAnthropicProviderǁ_convert_messages__mutmut_40, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_41': xǁAnthropicProviderǁ_convert_messages__mutmut_41, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_42': xǁAnthropicProviderǁ_convert_messages__mutmut_42, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_43': xǁAnthropicProviderǁ_convert_messages__mutmut_43, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_44': xǁAnthropicProviderǁ_convert_messages__mutmut_44, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_45': xǁAnthropicProviderǁ_convert_messages__mutmut_45, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_46': xǁAnthropicProviderǁ_convert_messages__mutmut_46, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_47': xǁAnthropicProviderǁ_convert_messages__mutmut_47, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_48': xǁAnthropicProviderǁ_convert_messages__mutmut_48, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_49': xǁAnthropicProviderǁ_convert_messages__mutmut_49, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_50': xǁAnthropicProviderǁ_convert_messages__mutmut_50, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_51': xǁAnthropicProviderǁ_convert_messages__mutmut_51, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_52': xǁAnthropicProviderǁ_convert_messages__mutmut_52, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_53': xǁAnthropicProviderǁ_convert_messages__mutmut_53, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_54': xǁAnthropicProviderǁ_convert_messages__mutmut_54, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_55': xǁAnthropicProviderǁ_convert_messages__mutmut_55, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_56': xǁAnthropicProviderǁ_convert_messages__mutmut_56, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_57': xǁAnthropicProviderǁ_convert_messages__mutmut_57, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_58': xǁAnthropicProviderǁ_convert_messages__mutmut_58, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_59': xǁAnthropicProviderǁ_convert_messages__mutmut_59, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_60': xǁAnthropicProviderǁ_convert_messages__mutmut_60, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_61': xǁAnthropicProviderǁ_convert_messages__mutmut_61, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_62': xǁAnthropicProviderǁ_convert_messages__mutmut_62, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_63': xǁAnthropicProviderǁ_convert_messages__mutmut_63, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_64': xǁAnthropicProviderǁ_convert_messages__mutmut_64, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_65': xǁAnthropicProviderǁ_convert_messages__mutmut_65, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_66': xǁAnthropicProviderǁ_convert_messages__mutmut_66, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_67': xǁAnthropicProviderǁ_convert_messages__mutmut_67, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_68': xǁAnthropicProviderǁ_convert_messages__mutmut_68, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_69': xǁAnthropicProviderǁ_convert_messages__mutmut_69, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_70': xǁAnthropicProviderǁ_convert_messages__mutmut_70, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_71': xǁAnthropicProviderǁ_convert_messages__mutmut_71, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_72': xǁAnthropicProviderǁ_convert_messages__mutmut_72, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_73': xǁAnthropicProviderǁ_convert_messages__mutmut_73, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_74': xǁAnthropicProviderǁ_convert_messages__mutmut_74, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_75': xǁAnthropicProviderǁ_convert_messages__mutmut_75, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_76': xǁAnthropicProviderǁ_convert_messages__mutmut_76, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_77': xǁAnthropicProviderǁ_convert_messages__mutmut_77, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_78': xǁAnthropicProviderǁ_convert_messages__mutmut_78, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_79': xǁAnthropicProviderǁ_convert_messages__mutmut_79, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_80': xǁAnthropicProviderǁ_convert_messages__mutmut_80, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_81': xǁAnthropicProviderǁ_convert_messages__mutmut_81, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_82': xǁAnthropicProviderǁ_convert_messages__mutmut_82, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_83': xǁAnthropicProviderǁ_convert_messages__mutmut_83, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_84': xǁAnthropicProviderǁ_convert_messages__mutmut_84, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_85': xǁAnthropicProviderǁ_convert_messages__mutmut_85, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_86': xǁAnthropicProviderǁ_convert_messages__mutmut_86, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_87': xǁAnthropicProviderǁ_convert_messages__mutmut_87, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_88': xǁAnthropicProviderǁ_convert_messages__mutmut_88, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_89': xǁAnthropicProviderǁ_convert_messages__mutmut_89, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_90': xǁAnthropicProviderǁ_convert_messages__mutmut_90, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_91': xǁAnthropicProviderǁ_convert_messages__mutmut_91, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_92': xǁAnthropicProviderǁ_convert_messages__mutmut_92, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_93': xǁAnthropicProviderǁ_convert_messages__mutmut_93, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_94': xǁAnthropicProviderǁ_convert_messages__mutmut_94, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_95': xǁAnthropicProviderǁ_convert_messages__mutmut_95, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_96': xǁAnthropicProviderǁ_convert_messages__mutmut_96, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_97': xǁAnthropicProviderǁ_convert_messages__mutmut_97, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_98': xǁAnthropicProviderǁ_convert_messages__mutmut_98, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_99': xǁAnthropicProviderǁ_convert_messages__mutmut_99, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_100': xǁAnthropicProviderǁ_convert_messages__mutmut_100, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_101': xǁAnthropicProviderǁ_convert_messages__mutmut_101, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_102': xǁAnthropicProviderǁ_convert_messages__mutmut_102, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_103': xǁAnthropicProviderǁ_convert_messages__mutmut_103, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_104': xǁAnthropicProviderǁ_convert_messages__mutmut_104, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_105': xǁAnthropicProviderǁ_convert_messages__mutmut_105, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_106': xǁAnthropicProviderǁ_convert_messages__mutmut_106, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_107': xǁAnthropicProviderǁ_convert_messages__mutmut_107, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_108': xǁAnthropicProviderǁ_convert_messages__mutmut_108, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_109': xǁAnthropicProviderǁ_convert_messages__mutmut_109, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_110': xǁAnthropicProviderǁ_convert_messages__mutmut_110, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_111': xǁAnthropicProviderǁ_convert_messages__mutmut_111, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_112': xǁAnthropicProviderǁ_convert_messages__mutmut_112, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_113': xǁAnthropicProviderǁ_convert_messages__mutmut_113, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_114': xǁAnthropicProviderǁ_convert_messages__mutmut_114, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_115': xǁAnthropicProviderǁ_convert_messages__mutmut_115, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_116': xǁAnthropicProviderǁ_convert_messages__mutmut_116, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_117': xǁAnthropicProviderǁ_convert_messages__mutmut_117, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_118': xǁAnthropicProviderǁ_convert_messages__mutmut_118, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_119': xǁAnthropicProviderǁ_convert_messages__mutmut_119, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_120': xǁAnthropicProviderǁ_convert_messages__mutmut_120, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_121': xǁAnthropicProviderǁ_convert_messages__mutmut_121, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_122': xǁAnthropicProviderǁ_convert_messages__mutmut_122, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_123': xǁAnthropicProviderǁ_convert_messages__mutmut_123, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_124': xǁAnthropicProviderǁ_convert_messages__mutmut_124, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_125': xǁAnthropicProviderǁ_convert_messages__mutmut_125, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_126': xǁAnthropicProviderǁ_convert_messages__mutmut_126, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_127': xǁAnthropicProviderǁ_convert_messages__mutmut_127, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_128': xǁAnthropicProviderǁ_convert_messages__mutmut_128, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_129': xǁAnthropicProviderǁ_convert_messages__mutmut_129, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_130': xǁAnthropicProviderǁ_convert_messages__mutmut_130, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_131': xǁAnthropicProviderǁ_convert_messages__mutmut_131, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_132': xǁAnthropicProviderǁ_convert_messages__mutmut_132, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_133': xǁAnthropicProviderǁ_convert_messages__mutmut_133, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_134': xǁAnthropicProviderǁ_convert_messages__mutmut_134, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_135': xǁAnthropicProviderǁ_convert_messages__mutmut_135, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_136': xǁAnthropicProviderǁ_convert_messages__mutmut_136, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_137': xǁAnthropicProviderǁ_convert_messages__mutmut_137, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_138': xǁAnthropicProviderǁ_convert_messages__mutmut_138, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_139': xǁAnthropicProviderǁ_convert_messages__mutmut_139, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_140': xǁAnthropicProviderǁ_convert_messages__mutmut_140, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_141': xǁAnthropicProviderǁ_convert_messages__mutmut_141, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_142': xǁAnthropicProviderǁ_convert_messages__mutmut_142, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_143': xǁAnthropicProviderǁ_convert_messages__mutmut_143, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_144': xǁAnthropicProviderǁ_convert_messages__mutmut_144, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_145': xǁAnthropicProviderǁ_convert_messages__mutmut_145, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_146': xǁAnthropicProviderǁ_convert_messages__mutmut_146, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_147': xǁAnthropicProviderǁ_convert_messages__mutmut_147, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_148': xǁAnthropicProviderǁ_convert_messages__mutmut_148, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_149': xǁAnthropicProviderǁ_convert_messages__mutmut_149, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_150': xǁAnthropicProviderǁ_convert_messages__mutmut_150, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_151': xǁAnthropicProviderǁ_convert_messages__mutmut_151, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_152': xǁAnthropicProviderǁ_convert_messages__mutmut_152, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_153': xǁAnthropicProviderǁ_convert_messages__mutmut_153, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_154': xǁAnthropicProviderǁ_convert_messages__mutmut_154, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_155': xǁAnthropicProviderǁ_convert_messages__mutmut_155, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_156': xǁAnthropicProviderǁ_convert_messages__mutmut_156, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_157': xǁAnthropicProviderǁ_convert_messages__mutmut_157, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_158': xǁAnthropicProviderǁ_convert_messages__mutmut_158, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_159': xǁAnthropicProviderǁ_convert_messages__mutmut_159, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_160': xǁAnthropicProviderǁ_convert_messages__mutmut_160, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_161': xǁAnthropicProviderǁ_convert_messages__mutmut_161, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_162': xǁAnthropicProviderǁ_convert_messages__mutmut_162, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_163': xǁAnthropicProviderǁ_convert_messages__mutmut_163, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_164': xǁAnthropicProviderǁ_convert_messages__mutmut_164, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_165': xǁAnthropicProviderǁ_convert_messages__mutmut_165, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_166': xǁAnthropicProviderǁ_convert_messages__mutmut_166, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_167': xǁAnthropicProviderǁ_convert_messages__mutmut_167, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_168': xǁAnthropicProviderǁ_convert_messages__mutmut_168, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_169': xǁAnthropicProviderǁ_convert_messages__mutmut_169, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_170': xǁAnthropicProviderǁ_convert_messages__mutmut_170, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_171': xǁAnthropicProviderǁ_convert_messages__mutmut_171, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_172': xǁAnthropicProviderǁ_convert_messages__mutmut_172, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_173': xǁAnthropicProviderǁ_convert_messages__mutmut_173, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_174': xǁAnthropicProviderǁ_convert_messages__mutmut_174, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_175': xǁAnthropicProviderǁ_convert_messages__mutmut_175, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_176': xǁAnthropicProviderǁ_convert_messages__mutmut_176, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_177': xǁAnthropicProviderǁ_convert_messages__mutmut_177, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_178': xǁAnthropicProviderǁ_convert_messages__mutmut_178, 
        'xǁAnthropicProviderǁ_convert_messages__mutmut_179': xǁAnthropicProviderǁ_convert_messages__mutmut_179
    }
    
    def _convert_messages(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁAnthropicProviderǁ_convert_messages__mutmut_orig"), object.__getattribute__(self, "xǁAnthropicProviderǁ_convert_messages__mutmut_mutants"), args, kwargs, self)
        return result 
    
    _convert_messages.__signature__ = _mutmut_signature(xǁAnthropicProviderǁ_convert_messages__mutmut_orig)
    xǁAnthropicProviderǁ_convert_messages__mutmut_orig.__name__ = 'xǁAnthropicProviderǁ_convert_messages'
    def xǁAnthropicProviderǁ_convert_tools__mutmut_orig(self, tools: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert tool definitions to Anthropic format."""
        anthropic_tools = []
        
        for tool in tools:
            if 'function' in tool:
                func = tool['function']
                anthropic_tools.append({
                    'name': func['name'],
                    'description': func.get('description', ''),
                    'input_schema': func.get('parameters', {})
                })
            else:
                # Already in Anthropic format
                anthropic_tools.append(tool)
                
        return anthropic_tools
        
    def xǁAnthropicProviderǁ_convert_tools__mutmut_1(self, tools: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert tool definitions to Anthropic format."""
        anthropic_tools = None
        
        for tool in tools:
            if 'function' in tool:
                func = tool['function']
                anthropic_tools.append({
                    'name': func['name'],
                    'description': func.get('description', ''),
                    'input_schema': func.get('parameters', {})
                })
            else:
                # Already in Anthropic format
                anthropic_tools.append(tool)
                
        return anthropic_tools
        
    def xǁAnthropicProviderǁ_convert_tools__mutmut_2(self, tools: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert tool definitions to Anthropic format."""
        anthropic_tools = []
        
        for tool in tools:
            if 'XXfunctionXX' in tool:
                func = tool['function']
                anthropic_tools.append({
                    'name': func['name'],
                    'description': func.get('description', ''),
                    'input_schema': func.get('parameters', {})
                })
            else:
                # Already in Anthropic format
                anthropic_tools.append(tool)
                
        return anthropic_tools
        
    def xǁAnthropicProviderǁ_convert_tools__mutmut_3(self, tools: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert tool definitions to Anthropic format."""
        anthropic_tools = []
        
        for tool in tools:
            if 'FUNCTION' in tool:
                func = tool['function']
                anthropic_tools.append({
                    'name': func['name'],
                    'description': func.get('description', ''),
                    'input_schema': func.get('parameters', {})
                })
            else:
                # Already in Anthropic format
                anthropic_tools.append(tool)
                
        return anthropic_tools
        
    def xǁAnthropicProviderǁ_convert_tools__mutmut_4(self, tools: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert tool definitions to Anthropic format."""
        anthropic_tools = []
        
        for tool in tools:
            if 'function' not in tool:
                func = tool['function']
                anthropic_tools.append({
                    'name': func['name'],
                    'description': func.get('description', ''),
                    'input_schema': func.get('parameters', {})
                })
            else:
                # Already in Anthropic format
                anthropic_tools.append(tool)
                
        return anthropic_tools
        
    def xǁAnthropicProviderǁ_convert_tools__mutmut_5(self, tools: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert tool definitions to Anthropic format."""
        anthropic_tools = []
        
        for tool in tools:
            if 'function' in tool:
                func = None
                anthropic_tools.append({
                    'name': func['name'],
                    'description': func.get('description', ''),
                    'input_schema': func.get('parameters', {})
                })
            else:
                # Already in Anthropic format
                anthropic_tools.append(tool)
                
        return anthropic_tools
        
    def xǁAnthropicProviderǁ_convert_tools__mutmut_6(self, tools: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert tool definitions to Anthropic format."""
        anthropic_tools = []
        
        for tool in tools:
            if 'function' in tool:
                func = tool['XXfunctionXX']
                anthropic_tools.append({
                    'name': func['name'],
                    'description': func.get('description', ''),
                    'input_schema': func.get('parameters', {})
                })
            else:
                # Already in Anthropic format
                anthropic_tools.append(tool)
                
        return anthropic_tools
        
    def xǁAnthropicProviderǁ_convert_tools__mutmut_7(self, tools: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert tool definitions to Anthropic format."""
        anthropic_tools = []
        
        for tool in tools:
            if 'function' in tool:
                func = tool['FUNCTION']
                anthropic_tools.append({
                    'name': func['name'],
                    'description': func.get('description', ''),
                    'input_schema': func.get('parameters', {})
                })
            else:
                # Already in Anthropic format
                anthropic_tools.append(tool)
                
        return anthropic_tools
        
    def xǁAnthropicProviderǁ_convert_tools__mutmut_8(self, tools: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert tool definitions to Anthropic format."""
        anthropic_tools = []
        
        for tool in tools:
            if 'function' in tool:
                func = tool['function']
                anthropic_tools.append(None)
            else:
                # Already in Anthropic format
                anthropic_tools.append(tool)
                
        return anthropic_tools
        
    def xǁAnthropicProviderǁ_convert_tools__mutmut_9(self, tools: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert tool definitions to Anthropic format."""
        anthropic_tools = []
        
        for tool in tools:
            if 'function' in tool:
                func = tool['function']
                anthropic_tools.append({
                    'XXnameXX': func['name'],
                    'description': func.get('description', ''),
                    'input_schema': func.get('parameters', {})
                })
            else:
                # Already in Anthropic format
                anthropic_tools.append(tool)
                
        return anthropic_tools
        
    def xǁAnthropicProviderǁ_convert_tools__mutmut_10(self, tools: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert tool definitions to Anthropic format."""
        anthropic_tools = []
        
        for tool in tools:
            if 'function' in tool:
                func = tool['function']
                anthropic_tools.append({
                    'NAME': func['name'],
                    'description': func.get('description', ''),
                    'input_schema': func.get('parameters', {})
                })
            else:
                # Already in Anthropic format
                anthropic_tools.append(tool)
                
        return anthropic_tools
        
    def xǁAnthropicProviderǁ_convert_tools__mutmut_11(self, tools: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert tool definitions to Anthropic format."""
        anthropic_tools = []
        
        for tool in tools:
            if 'function' in tool:
                func = tool['function']
                anthropic_tools.append({
                    'name': func['XXnameXX'],
                    'description': func.get('description', ''),
                    'input_schema': func.get('parameters', {})
                })
            else:
                # Already in Anthropic format
                anthropic_tools.append(tool)
                
        return anthropic_tools
        
    def xǁAnthropicProviderǁ_convert_tools__mutmut_12(self, tools: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert tool definitions to Anthropic format."""
        anthropic_tools = []
        
        for tool in tools:
            if 'function' in tool:
                func = tool['function']
                anthropic_tools.append({
                    'name': func['NAME'],
                    'description': func.get('description', ''),
                    'input_schema': func.get('parameters', {})
                })
            else:
                # Already in Anthropic format
                anthropic_tools.append(tool)
                
        return anthropic_tools
        
    def xǁAnthropicProviderǁ_convert_tools__mutmut_13(self, tools: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert tool definitions to Anthropic format."""
        anthropic_tools = []
        
        for tool in tools:
            if 'function' in tool:
                func = tool['function']
                anthropic_tools.append({
                    'name': func['name'],
                    'XXdescriptionXX': func.get('description', ''),
                    'input_schema': func.get('parameters', {})
                })
            else:
                # Already in Anthropic format
                anthropic_tools.append(tool)
                
        return anthropic_tools
        
    def xǁAnthropicProviderǁ_convert_tools__mutmut_14(self, tools: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert tool definitions to Anthropic format."""
        anthropic_tools = []
        
        for tool in tools:
            if 'function' in tool:
                func = tool['function']
                anthropic_tools.append({
                    'name': func['name'],
                    'DESCRIPTION': func.get('description', ''),
                    'input_schema': func.get('parameters', {})
                })
            else:
                # Already in Anthropic format
                anthropic_tools.append(tool)
                
        return anthropic_tools
        
    def xǁAnthropicProviderǁ_convert_tools__mutmut_15(self, tools: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert tool definitions to Anthropic format."""
        anthropic_tools = []
        
        for tool in tools:
            if 'function' in tool:
                func = tool['function']
                anthropic_tools.append({
                    'name': func['name'],
                    'description': func.get(None, ''),
                    'input_schema': func.get('parameters', {})
                })
            else:
                # Already in Anthropic format
                anthropic_tools.append(tool)
                
        return anthropic_tools
        
    def xǁAnthropicProviderǁ_convert_tools__mutmut_16(self, tools: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert tool definitions to Anthropic format."""
        anthropic_tools = []
        
        for tool in tools:
            if 'function' in tool:
                func = tool['function']
                anthropic_tools.append({
                    'name': func['name'],
                    'description': func.get('description', None),
                    'input_schema': func.get('parameters', {})
                })
            else:
                # Already in Anthropic format
                anthropic_tools.append(tool)
                
        return anthropic_tools
        
    def xǁAnthropicProviderǁ_convert_tools__mutmut_17(self, tools: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert tool definitions to Anthropic format."""
        anthropic_tools = []
        
        for tool in tools:
            if 'function' in tool:
                func = tool['function']
                anthropic_tools.append({
                    'name': func['name'],
                    'description': func.get(''),
                    'input_schema': func.get('parameters', {})
                })
            else:
                # Already in Anthropic format
                anthropic_tools.append(tool)
                
        return anthropic_tools
        
    def xǁAnthropicProviderǁ_convert_tools__mutmut_18(self, tools: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert tool definitions to Anthropic format."""
        anthropic_tools = []
        
        for tool in tools:
            if 'function' in tool:
                func = tool['function']
                anthropic_tools.append({
                    'name': func['name'],
                    'description': func.get('description', ),
                    'input_schema': func.get('parameters', {})
                })
            else:
                # Already in Anthropic format
                anthropic_tools.append(tool)
                
        return anthropic_tools
        
    def xǁAnthropicProviderǁ_convert_tools__mutmut_19(self, tools: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert tool definitions to Anthropic format."""
        anthropic_tools = []
        
        for tool in tools:
            if 'function' in tool:
                func = tool['function']
                anthropic_tools.append({
                    'name': func['name'],
                    'description': func.get('XXdescriptionXX', ''),
                    'input_schema': func.get('parameters', {})
                })
            else:
                # Already in Anthropic format
                anthropic_tools.append(tool)
                
        return anthropic_tools
        
    def xǁAnthropicProviderǁ_convert_tools__mutmut_20(self, tools: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert tool definitions to Anthropic format."""
        anthropic_tools = []
        
        for tool in tools:
            if 'function' in tool:
                func = tool['function']
                anthropic_tools.append({
                    'name': func['name'],
                    'description': func.get('DESCRIPTION', ''),
                    'input_schema': func.get('parameters', {})
                })
            else:
                # Already in Anthropic format
                anthropic_tools.append(tool)
                
        return anthropic_tools
        
    def xǁAnthropicProviderǁ_convert_tools__mutmut_21(self, tools: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert tool definitions to Anthropic format."""
        anthropic_tools = []
        
        for tool in tools:
            if 'function' in tool:
                func = tool['function']
                anthropic_tools.append({
                    'name': func['name'],
                    'description': func.get('description', 'XXXX'),
                    'input_schema': func.get('parameters', {})
                })
            else:
                # Already in Anthropic format
                anthropic_tools.append(tool)
                
        return anthropic_tools
        
    def xǁAnthropicProviderǁ_convert_tools__mutmut_22(self, tools: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert tool definitions to Anthropic format."""
        anthropic_tools = []
        
        for tool in tools:
            if 'function' in tool:
                func = tool['function']
                anthropic_tools.append({
                    'name': func['name'],
                    'description': func.get('description', ''),
                    'XXinput_schemaXX': func.get('parameters', {})
                })
            else:
                # Already in Anthropic format
                anthropic_tools.append(tool)
                
        return anthropic_tools
        
    def xǁAnthropicProviderǁ_convert_tools__mutmut_23(self, tools: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert tool definitions to Anthropic format."""
        anthropic_tools = []
        
        for tool in tools:
            if 'function' in tool:
                func = tool['function']
                anthropic_tools.append({
                    'name': func['name'],
                    'description': func.get('description', ''),
                    'INPUT_SCHEMA': func.get('parameters', {})
                })
            else:
                # Already in Anthropic format
                anthropic_tools.append(tool)
                
        return anthropic_tools
        
    def xǁAnthropicProviderǁ_convert_tools__mutmut_24(self, tools: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert tool definitions to Anthropic format."""
        anthropic_tools = []
        
        for tool in tools:
            if 'function' in tool:
                func = tool['function']
                anthropic_tools.append({
                    'name': func['name'],
                    'description': func.get('description', ''),
                    'input_schema': func.get(None, {})
                })
            else:
                # Already in Anthropic format
                anthropic_tools.append(tool)
                
        return anthropic_tools
        
    def xǁAnthropicProviderǁ_convert_tools__mutmut_25(self, tools: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert tool definitions to Anthropic format."""
        anthropic_tools = []
        
        for tool in tools:
            if 'function' in tool:
                func = tool['function']
                anthropic_tools.append({
                    'name': func['name'],
                    'description': func.get('description', ''),
                    'input_schema': func.get('parameters', None)
                })
            else:
                # Already in Anthropic format
                anthropic_tools.append(tool)
                
        return anthropic_tools
        
    def xǁAnthropicProviderǁ_convert_tools__mutmut_26(self, tools: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert tool definitions to Anthropic format."""
        anthropic_tools = []
        
        for tool in tools:
            if 'function' in tool:
                func = tool['function']
                anthropic_tools.append({
                    'name': func['name'],
                    'description': func.get('description', ''),
                    'input_schema': func.get({})
                })
            else:
                # Already in Anthropic format
                anthropic_tools.append(tool)
                
        return anthropic_tools
        
    def xǁAnthropicProviderǁ_convert_tools__mutmut_27(self, tools: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert tool definitions to Anthropic format."""
        anthropic_tools = []
        
        for tool in tools:
            if 'function' in tool:
                func = tool['function']
                anthropic_tools.append({
                    'name': func['name'],
                    'description': func.get('description', ''),
                    'input_schema': func.get('parameters', )
                })
            else:
                # Already in Anthropic format
                anthropic_tools.append(tool)
                
        return anthropic_tools
        
    def xǁAnthropicProviderǁ_convert_tools__mutmut_28(self, tools: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert tool definitions to Anthropic format."""
        anthropic_tools = []
        
        for tool in tools:
            if 'function' in tool:
                func = tool['function']
                anthropic_tools.append({
                    'name': func['name'],
                    'description': func.get('description', ''),
                    'input_schema': func.get('XXparametersXX', {})
                })
            else:
                # Already in Anthropic format
                anthropic_tools.append(tool)
                
        return anthropic_tools
        
    def xǁAnthropicProviderǁ_convert_tools__mutmut_29(self, tools: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert tool definitions to Anthropic format."""
        anthropic_tools = []
        
        for tool in tools:
            if 'function' in tool:
                func = tool['function']
                anthropic_tools.append({
                    'name': func['name'],
                    'description': func.get('description', ''),
                    'input_schema': func.get('PARAMETERS', {})
                })
            else:
                # Already in Anthropic format
                anthropic_tools.append(tool)
                
        return anthropic_tools
        
    def xǁAnthropicProviderǁ_convert_tools__mutmut_30(self, tools: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert tool definitions to Anthropic format."""
        anthropic_tools = []
        
        for tool in tools:
            if 'function' in tool:
                func = tool['function']
                anthropic_tools.append({
                    'name': func['name'],
                    'description': func.get('description', ''),
                    'input_schema': func.get('parameters', {})
                })
            else:
                # Already in Anthropic format
                anthropic_tools.append(None)
                
        return anthropic_tools
        
    
    xǁAnthropicProviderǁ_convert_tools__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁAnthropicProviderǁ_convert_tools__mutmut_1': xǁAnthropicProviderǁ_convert_tools__mutmut_1, 
        'xǁAnthropicProviderǁ_convert_tools__mutmut_2': xǁAnthropicProviderǁ_convert_tools__mutmut_2, 
        'xǁAnthropicProviderǁ_convert_tools__mutmut_3': xǁAnthropicProviderǁ_convert_tools__mutmut_3, 
        'xǁAnthropicProviderǁ_convert_tools__mutmut_4': xǁAnthropicProviderǁ_convert_tools__mutmut_4, 
        'xǁAnthropicProviderǁ_convert_tools__mutmut_5': xǁAnthropicProviderǁ_convert_tools__mutmut_5, 
        'xǁAnthropicProviderǁ_convert_tools__mutmut_6': xǁAnthropicProviderǁ_convert_tools__mutmut_6, 
        'xǁAnthropicProviderǁ_convert_tools__mutmut_7': xǁAnthropicProviderǁ_convert_tools__mutmut_7, 
        'xǁAnthropicProviderǁ_convert_tools__mutmut_8': xǁAnthropicProviderǁ_convert_tools__mutmut_8, 
        'xǁAnthropicProviderǁ_convert_tools__mutmut_9': xǁAnthropicProviderǁ_convert_tools__mutmut_9, 
        'xǁAnthropicProviderǁ_convert_tools__mutmut_10': xǁAnthropicProviderǁ_convert_tools__mutmut_10, 
        'xǁAnthropicProviderǁ_convert_tools__mutmut_11': xǁAnthropicProviderǁ_convert_tools__mutmut_11, 
        'xǁAnthropicProviderǁ_convert_tools__mutmut_12': xǁAnthropicProviderǁ_convert_tools__mutmut_12, 
        'xǁAnthropicProviderǁ_convert_tools__mutmut_13': xǁAnthropicProviderǁ_convert_tools__mutmut_13, 
        'xǁAnthropicProviderǁ_convert_tools__mutmut_14': xǁAnthropicProviderǁ_convert_tools__mutmut_14, 
        'xǁAnthropicProviderǁ_convert_tools__mutmut_15': xǁAnthropicProviderǁ_convert_tools__mutmut_15, 
        'xǁAnthropicProviderǁ_convert_tools__mutmut_16': xǁAnthropicProviderǁ_convert_tools__mutmut_16, 
        'xǁAnthropicProviderǁ_convert_tools__mutmut_17': xǁAnthropicProviderǁ_convert_tools__mutmut_17, 
        'xǁAnthropicProviderǁ_convert_tools__mutmut_18': xǁAnthropicProviderǁ_convert_tools__mutmut_18, 
        'xǁAnthropicProviderǁ_convert_tools__mutmut_19': xǁAnthropicProviderǁ_convert_tools__mutmut_19, 
        'xǁAnthropicProviderǁ_convert_tools__mutmut_20': xǁAnthropicProviderǁ_convert_tools__mutmut_20, 
        'xǁAnthropicProviderǁ_convert_tools__mutmut_21': xǁAnthropicProviderǁ_convert_tools__mutmut_21, 
        'xǁAnthropicProviderǁ_convert_tools__mutmut_22': xǁAnthropicProviderǁ_convert_tools__mutmut_22, 
        'xǁAnthropicProviderǁ_convert_tools__mutmut_23': xǁAnthropicProviderǁ_convert_tools__mutmut_23, 
        'xǁAnthropicProviderǁ_convert_tools__mutmut_24': xǁAnthropicProviderǁ_convert_tools__mutmut_24, 
        'xǁAnthropicProviderǁ_convert_tools__mutmut_25': xǁAnthropicProviderǁ_convert_tools__mutmut_25, 
        'xǁAnthropicProviderǁ_convert_tools__mutmut_26': xǁAnthropicProviderǁ_convert_tools__mutmut_26, 
        'xǁAnthropicProviderǁ_convert_tools__mutmut_27': xǁAnthropicProviderǁ_convert_tools__mutmut_27, 
        'xǁAnthropicProviderǁ_convert_tools__mutmut_28': xǁAnthropicProviderǁ_convert_tools__mutmut_28, 
        'xǁAnthropicProviderǁ_convert_tools__mutmut_29': xǁAnthropicProviderǁ_convert_tools__mutmut_29, 
        'xǁAnthropicProviderǁ_convert_tools__mutmut_30': xǁAnthropicProviderǁ_convert_tools__mutmut_30
    }
    
    def _convert_tools(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁAnthropicProviderǁ_convert_tools__mutmut_orig"), object.__getattribute__(self, "xǁAnthropicProviderǁ_convert_tools__mutmut_mutants"), args, kwargs, self)
        return result 
    
    _convert_tools.__signature__ = _mutmut_signature(xǁAnthropicProviderǁ_convert_tools__mutmut_orig)
    xǁAnthropicProviderǁ_convert_tools__mutmut_orig.__name__ = 'xǁAnthropicProviderǁ_convert_tools'
    def xǁAnthropicProviderǁ_convert_response__mutmut_orig(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=block.id,
                    name=block.name,
                    arguments=block.input
                ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'prompt_tokens': response.usage.input_tokens,
                'completion_tokens': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=content_text if content_text else None,
            tool_calls=tool_calls,
            usage=usage,
            model=response.model,
            provider=self.provider_name,
            raw_response=response,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_1(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = None
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=block.id,
                    name=block.name,
                    arguments=block.input
                ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'prompt_tokens': response.usage.input_tokens,
                'completion_tokens': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=content_text if content_text else None,
            tool_calls=tool_calls,
            usage=usage,
            model=response.model,
            provider=self.provider_name,
            raw_response=response,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_2(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = "XXXX"
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=block.id,
                    name=block.name,
                    arguments=block.input
                ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'prompt_tokens': response.usage.input_tokens,
                'completion_tokens': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=content_text if content_text else None,
            tool_calls=tool_calls,
            usage=usage,
            model=response.model,
            provider=self.provider_name,
            raw_response=response,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_3(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = None
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=block.id,
                    name=block.name,
                    arguments=block.input
                ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'prompt_tokens': response.usage.input_tokens,
                'completion_tokens': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=content_text if content_text else None,
            tool_calls=tool_calls,
            usage=usage,
            model=response.model,
            provider=self.provider_name,
            raw_response=response,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_4(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text = block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=block.id,
                    name=block.name,
                    arguments=block.input
                ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'prompt_tokens': response.usage.input_tokens,
                'completion_tokens': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=content_text if content_text else None,
            tool_calls=tool_calls,
            usage=usage,
            model=response.model,
            provider=self.provider_name,
            raw_response=response,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_5(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text -= block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=block.id,
                    name=block.name,
                    arguments=block.input
                ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'prompt_tokens': response.usage.input_tokens,
                'completion_tokens': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=content_text if content_text else None,
            tool_calls=tool_calls,
            usage=usage,
            model=response.model,
            provider=self.provider_name,
            raw_response=response,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_6(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(None)
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'prompt_tokens': response.usage.input_tokens,
                'completion_tokens': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=content_text if content_text else None,
            tool_calls=tool_calls,
            usage=usage,
            model=response.model,
            provider=self.provider_name,
            raw_response=response,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_7(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=None,
                    name=block.name,
                    arguments=block.input
                ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'prompt_tokens': response.usage.input_tokens,
                'completion_tokens': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=content_text if content_text else None,
            tool_calls=tool_calls,
            usage=usage,
            model=response.model,
            provider=self.provider_name,
            raw_response=response,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_8(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=block.id,
                    name=None,
                    arguments=block.input
                ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'prompt_tokens': response.usage.input_tokens,
                'completion_tokens': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=content_text if content_text else None,
            tool_calls=tool_calls,
            usage=usage,
            model=response.model,
            provider=self.provider_name,
            raw_response=response,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_9(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=block.id,
                    name=block.name,
                    arguments=None
                ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'prompt_tokens': response.usage.input_tokens,
                'completion_tokens': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=content_text if content_text else None,
            tool_calls=tool_calls,
            usage=usage,
            model=response.model,
            provider=self.provider_name,
            raw_response=response,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_10(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    name=block.name,
                    arguments=block.input
                ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'prompt_tokens': response.usage.input_tokens,
                'completion_tokens': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=content_text if content_text else None,
            tool_calls=tool_calls,
            usage=usage,
            model=response.model,
            provider=self.provider_name,
            raw_response=response,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_11(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=block.id,
                    arguments=block.input
                ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'prompt_tokens': response.usage.input_tokens,
                'completion_tokens': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=content_text if content_text else None,
            tool_calls=tool_calls,
            usage=usage,
            model=response.model,
            provider=self.provider_name,
            raw_response=response,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_12(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=block.id,
                    name=block.name,
                    ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'prompt_tokens': response.usage.input_tokens,
                'completion_tokens': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=content_text if content_text else None,
            tool_calls=tool_calls,
            usage=usage,
            model=response.model,
            provider=self.provider_name,
            raw_response=response,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_13(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=block.id,
                    name=block.name,
                    arguments=block.input
                ))
                
        # Extract usage info
        usage = ""
        if response.usage:
            usage = {
                'prompt_tokens': response.usage.input_tokens,
                'completion_tokens': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=content_text if content_text else None,
            tool_calls=tool_calls,
            usage=usage,
            model=response.model,
            provider=self.provider_name,
            raw_response=response,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_14(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=block.id,
                    name=block.name,
                    arguments=block.input
                ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = None
            
        return ProviderResponse(
            content=content_text if content_text else None,
            tool_calls=tool_calls,
            usage=usage,
            model=response.model,
            provider=self.provider_name,
            raw_response=response,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_15(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=block.id,
                    name=block.name,
                    arguments=block.input
                ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'XXprompt_tokensXX': response.usage.input_tokens,
                'completion_tokens': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=content_text if content_text else None,
            tool_calls=tool_calls,
            usage=usage,
            model=response.model,
            provider=self.provider_name,
            raw_response=response,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_16(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=block.id,
                    name=block.name,
                    arguments=block.input
                ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'PROMPT_TOKENS': response.usage.input_tokens,
                'completion_tokens': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=content_text if content_text else None,
            tool_calls=tool_calls,
            usage=usage,
            model=response.model,
            provider=self.provider_name,
            raw_response=response,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_17(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=block.id,
                    name=block.name,
                    arguments=block.input
                ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'prompt_tokens': response.usage.input_tokens,
                'XXcompletion_tokensXX': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=content_text if content_text else None,
            tool_calls=tool_calls,
            usage=usage,
            model=response.model,
            provider=self.provider_name,
            raw_response=response,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_18(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=block.id,
                    name=block.name,
                    arguments=block.input
                ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'prompt_tokens': response.usage.input_tokens,
                'COMPLETION_TOKENS': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=content_text if content_text else None,
            tool_calls=tool_calls,
            usage=usage,
            model=response.model,
            provider=self.provider_name,
            raw_response=response,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_19(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=block.id,
                    name=block.name,
                    arguments=block.input
                ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'prompt_tokens': response.usage.input_tokens,
                'completion_tokens': response.usage.output_tokens,
                'XXtotal_tokensXX': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=content_text if content_text else None,
            tool_calls=tool_calls,
            usage=usage,
            model=response.model,
            provider=self.provider_name,
            raw_response=response,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_20(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=block.id,
                    name=block.name,
                    arguments=block.input
                ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'prompt_tokens': response.usage.input_tokens,
                'completion_tokens': response.usage.output_tokens,
                'TOTAL_TOKENS': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=content_text if content_text else None,
            tool_calls=tool_calls,
            usage=usage,
            model=response.model,
            provider=self.provider_name,
            raw_response=response,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_21(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=block.id,
                    name=block.name,
                    arguments=block.input
                ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'prompt_tokens': response.usage.input_tokens,
                'completion_tokens': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens - response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=content_text if content_text else None,
            tool_calls=tool_calls,
            usage=usage,
            model=response.model,
            provider=self.provider_name,
            raw_response=response,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_22(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=block.id,
                    name=block.name,
                    arguments=block.input
                ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'prompt_tokens': response.usage.input_tokens,
                'completion_tokens': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=None,
            tool_calls=tool_calls,
            usage=usage,
            model=response.model,
            provider=self.provider_name,
            raw_response=response,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_23(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=block.id,
                    name=block.name,
                    arguments=block.input
                ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'prompt_tokens': response.usage.input_tokens,
                'completion_tokens': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=content_text if content_text else None,
            tool_calls=None,
            usage=usage,
            model=response.model,
            provider=self.provider_name,
            raw_response=response,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_24(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=block.id,
                    name=block.name,
                    arguments=block.input
                ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'prompt_tokens': response.usage.input_tokens,
                'completion_tokens': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=content_text if content_text else None,
            tool_calls=tool_calls,
            usage=None,
            model=response.model,
            provider=self.provider_name,
            raw_response=response,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_25(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=block.id,
                    name=block.name,
                    arguments=block.input
                ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'prompt_tokens': response.usage.input_tokens,
                'completion_tokens': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=content_text if content_text else None,
            tool_calls=tool_calls,
            usage=usage,
            model=None,
            provider=self.provider_name,
            raw_response=response,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_26(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=block.id,
                    name=block.name,
                    arguments=block.input
                ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'prompt_tokens': response.usage.input_tokens,
                'completion_tokens': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=content_text if content_text else None,
            tool_calls=tool_calls,
            usage=usage,
            model=response.model,
            provider=None,
            raw_response=response,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_27(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=block.id,
                    name=block.name,
                    arguments=block.input
                ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'prompt_tokens': response.usage.input_tokens,
                'completion_tokens': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=content_text if content_text else None,
            tool_calls=tool_calls,
            usage=usage,
            model=response.model,
            provider=self.provider_name,
            raw_response=None,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_28(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=block.id,
                    name=block.name,
                    arguments=block.input
                ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'prompt_tokens': response.usage.input_tokens,
                'completion_tokens': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=content_text if content_text else None,
            tool_calls=tool_calls,
            usage=usage,
            model=response.model,
            provider=self.provider_name,
            raw_response=response,
            finish_reason=None
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_29(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=block.id,
                    name=block.name,
                    arguments=block.input
                ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'prompt_tokens': response.usage.input_tokens,
                'completion_tokens': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            tool_calls=tool_calls,
            usage=usage,
            model=response.model,
            provider=self.provider_name,
            raw_response=response,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_30(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=block.id,
                    name=block.name,
                    arguments=block.input
                ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'prompt_tokens': response.usage.input_tokens,
                'completion_tokens': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=content_text if content_text else None,
            usage=usage,
            model=response.model,
            provider=self.provider_name,
            raw_response=response,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_31(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=block.id,
                    name=block.name,
                    arguments=block.input
                ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'prompt_tokens': response.usage.input_tokens,
                'completion_tokens': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=content_text if content_text else None,
            tool_calls=tool_calls,
            model=response.model,
            provider=self.provider_name,
            raw_response=response,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_32(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=block.id,
                    name=block.name,
                    arguments=block.input
                ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'prompt_tokens': response.usage.input_tokens,
                'completion_tokens': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=content_text if content_text else None,
            tool_calls=tool_calls,
            usage=usage,
            provider=self.provider_name,
            raw_response=response,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_33(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=block.id,
                    name=block.name,
                    arguments=block.input
                ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'prompt_tokens': response.usage.input_tokens,
                'completion_tokens': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=content_text if content_text else None,
            tool_calls=tool_calls,
            usage=usage,
            model=response.model,
            raw_response=response,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_34(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=block.id,
                    name=block.name,
                    arguments=block.input
                ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'prompt_tokens': response.usage.input_tokens,
                'completion_tokens': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=content_text if content_text else None,
            tool_calls=tool_calls,
            usage=usage,
            model=response.model,
            provider=self.provider_name,
            finish_reason=response.stop_reason
        )
        
    def xǁAnthropicProviderǁ_convert_response__mutmut_35(self, response: Message) -> ProviderResponse:
        """Convert Anthropic response to standardized format."""
        content_text = ""
        tool_calls = []
        
        # Process content blocks
        for block in response.content:
            if isinstance(block, TextBlock):
                content_text += block.text
            elif isinstance(block, ToolUseBlock):
                tool_calls.append(ToolCall(
                    id=block.id,
                    name=block.name,
                    arguments=block.input
                ))
                
        # Extract usage info
        usage = None
        if response.usage:
            usage = {
                'prompt_tokens': response.usage.input_tokens,
                'completion_tokens': response.usage.output_tokens,
                'total_tokens': response.usage.input_tokens + response.usage.output_tokens,
            }
            
        return ProviderResponse(
            content=content_text if content_text else None,
            tool_calls=tool_calls,
            usage=usage,
            model=response.model,
            provider=self.provider_name,
            raw_response=response,
            )
        
    
    xǁAnthropicProviderǁ_convert_response__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁAnthropicProviderǁ_convert_response__mutmut_1': xǁAnthropicProviderǁ_convert_response__mutmut_1, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_2': xǁAnthropicProviderǁ_convert_response__mutmut_2, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_3': xǁAnthropicProviderǁ_convert_response__mutmut_3, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_4': xǁAnthropicProviderǁ_convert_response__mutmut_4, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_5': xǁAnthropicProviderǁ_convert_response__mutmut_5, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_6': xǁAnthropicProviderǁ_convert_response__mutmut_6, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_7': xǁAnthropicProviderǁ_convert_response__mutmut_7, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_8': xǁAnthropicProviderǁ_convert_response__mutmut_8, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_9': xǁAnthropicProviderǁ_convert_response__mutmut_9, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_10': xǁAnthropicProviderǁ_convert_response__mutmut_10, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_11': xǁAnthropicProviderǁ_convert_response__mutmut_11, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_12': xǁAnthropicProviderǁ_convert_response__mutmut_12, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_13': xǁAnthropicProviderǁ_convert_response__mutmut_13, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_14': xǁAnthropicProviderǁ_convert_response__mutmut_14, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_15': xǁAnthropicProviderǁ_convert_response__mutmut_15, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_16': xǁAnthropicProviderǁ_convert_response__mutmut_16, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_17': xǁAnthropicProviderǁ_convert_response__mutmut_17, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_18': xǁAnthropicProviderǁ_convert_response__mutmut_18, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_19': xǁAnthropicProviderǁ_convert_response__mutmut_19, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_20': xǁAnthropicProviderǁ_convert_response__mutmut_20, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_21': xǁAnthropicProviderǁ_convert_response__mutmut_21, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_22': xǁAnthropicProviderǁ_convert_response__mutmut_22, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_23': xǁAnthropicProviderǁ_convert_response__mutmut_23, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_24': xǁAnthropicProviderǁ_convert_response__mutmut_24, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_25': xǁAnthropicProviderǁ_convert_response__mutmut_25, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_26': xǁAnthropicProviderǁ_convert_response__mutmut_26, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_27': xǁAnthropicProviderǁ_convert_response__mutmut_27, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_28': xǁAnthropicProviderǁ_convert_response__mutmut_28, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_29': xǁAnthropicProviderǁ_convert_response__mutmut_29, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_30': xǁAnthropicProviderǁ_convert_response__mutmut_30, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_31': xǁAnthropicProviderǁ_convert_response__mutmut_31, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_32': xǁAnthropicProviderǁ_convert_response__mutmut_32, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_33': xǁAnthropicProviderǁ_convert_response__mutmut_33, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_34': xǁAnthropicProviderǁ_convert_response__mutmut_34, 
        'xǁAnthropicProviderǁ_convert_response__mutmut_35': xǁAnthropicProviderǁ_convert_response__mutmut_35
    }
    
    def _convert_response(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁAnthropicProviderǁ_convert_response__mutmut_orig"), object.__getattribute__(self, "xǁAnthropicProviderǁ_convert_response__mutmut_mutants"), args, kwargs, self)
        return result 
    
    _convert_response.__signature__ = _mutmut_signature(xǁAnthropicProviderǁ_convert_response__mutmut_orig)
    xǁAnthropicProviderǁ_convert_response__mutmut_orig.__name__ = 'xǁAnthropicProviderǁ_convert_response'
    def xǁAnthropicProviderǁsupports_tool_calling__mutmut_orig(self) -> bool:
        """Check if the model supports tool calling."""
        from ..capabilities import get_model_capabilities
        capabilities = get_model_capabilities(self.model_name)
        return capabilities.tool_calling if capabilities else False
        
    def xǁAnthropicProviderǁsupports_tool_calling__mutmut_1(self) -> bool:
        """Check if the model supports tool calling."""
        from ..capabilities import get_model_capabilities
        capabilities = None
        return capabilities.tool_calling if capabilities else False
        
    def xǁAnthropicProviderǁsupports_tool_calling__mutmut_2(self) -> bool:
        """Check if the model supports tool calling."""
        from ..capabilities import get_model_capabilities
        capabilities = get_model_capabilities(None)
        return capabilities.tool_calling if capabilities else False
        
    def xǁAnthropicProviderǁsupports_tool_calling__mutmut_3(self) -> bool:
        """Check if the model supports tool calling."""
        from ..capabilities import get_model_capabilities
        capabilities = get_model_capabilities(self.model_name)
        return capabilities.tool_calling if capabilities else True
        
    
    xǁAnthropicProviderǁsupports_tool_calling__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁAnthropicProviderǁsupports_tool_calling__mutmut_1': xǁAnthropicProviderǁsupports_tool_calling__mutmut_1, 
        'xǁAnthropicProviderǁsupports_tool_calling__mutmut_2': xǁAnthropicProviderǁsupports_tool_calling__mutmut_2, 
        'xǁAnthropicProviderǁsupports_tool_calling__mutmut_3': xǁAnthropicProviderǁsupports_tool_calling__mutmut_3
    }
    
    def supports_tool_calling(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁAnthropicProviderǁsupports_tool_calling__mutmut_orig"), object.__getattribute__(self, "xǁAnthropicProviderǁsupports_tool_calling__mutmut_mutants"), args, kwargs, self)
        return result 
    
    supports_tool_calling.__signature__ = _mutmut_signature(xǁAnthropicProviderǁsupports_tool_calling__mutmut_orig)
    xǁAnthropicProviderǁsupports_tool_calling__mutmut_orig.__name__ = 'xǁAnthropicProviderǁsupports_tool_calling'
    def xǁAnthropicProviderǁsupports_parallel_tools__mutmut_orig(self) -> bool:
        """Check if the model supports parallel tool execution."""
        from ..capabilities import get_model_capabilities
        capabilities = get_model_capabilities(self.model_name)
        return capabilities.supports_parallel_tools if capabilities else False
    def xǁAnthropicProviderǁsupports_parallel_tools__mutmut_1(self) -> bool:
        """Check if the model supports parallel tool execution."""
        from ..capabilities import get_model_capabilities
        capabilities = None
        return capabilities.supports_parallel_tools if capabilities else False
    def xǁAnthropicProviderǁsupports_parallel_tools__mutmut_2(self) -> bool:
        """Check if the model supports parallel tool execution."""
        from ..capabilities import get_model_capabilities
        capabilities = get_model_capabilities(None)
        return capabilities.supports_parallel_tools if capabilities else False
    def xǁAnthropicProviderǁsupports_parallel_tools__mutmut_3(self) -> bool:
        """Check if the model supports parallel tool execution."""
        from ..capabilities import get_model_capabilities
        capabilities = get_model_capabilities(self.model_name)
        return capabilities.supports_parallel_tools if capabilities else True
    
    xǁAnthropicProviderǁsupports_parallel_tools__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁAnthropicProviderǁsupports_parallel_tools__mutmut_1': xǁAnthropicProviderǁsupports_parallel_tools__mutmut_1, 
        'xǁAnthropicProviderǁsupports_parallel_tools__mutmut_2': xǁAnthropicProviderǁsupports_parallel_tools__mutmut_2, 
        'xǁAnthropicProviderǁsupports_parallel_tools__mutmut_3': xǁAnthropicProviderǁsupports_parallel_tools__mutmut_3
    }
    
    def supports_parallel_tools(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁAnthropicProviderǁsupports_parallel_tools__mutmut_orig"), object.__getattribute__(self, "xǁAnthropicProviderǁsupports_parallel_tools__mutmut_mutants"), args, kwargs, self)
        return result 
    
    supports_parallel_tools.__signature__ = _mutmut_signature(xǁAnthropicProviderǁsupports_parallel_tools__mutmut_orig)
    xǁAnthropicProviderǁsupports_parallel_tools__mutmut_orig.__name__ = 'xǁAnthropicProviderǁsupports_parallel_tools'
    
    def xǁAnthropicProviderǁsupports_images__mutmut_orig(self) -> bool:
        """Check if the model supports image input."""
        from ..capabilities import get_model_capabilities
        capabilities = get_model_capabilities(self.model_name)
        return capabilities.supports_image_input if capabilities else False
    
    def xǁAnthropicProviderǁsupports_images__mutmut_1(self) -> bool:
        """Check if the model supports image input."""
        from ..capabilities import get_model_capabilities
        capabilities = None
        return capabilities.supports_image_input if capabilities else False
    
    def xǁAnthropicProviderǁsupports_images__mutmut_2(self) -> bool:
        """Check if the model supports image input."""
        from ..capabilities import get_model_capabilities
        capabilities = get_model_capabilities(None)
        return capabilities.supports_image_input if capabilities else False
    
    def xǁAnthropicProviderǁsupports_images__mutmut_3(self) -> bool:
        """Check if the model supports image input."""
        from ..capabilities import get_model_capabilities
        capabilities = get_model_capabilities(self.model_name)
        return capabilities.supports_image_input if capabilities else True
    
    xǁAnthropicProviderǁsupports_images__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁAnthropicProviderǁsupports_images__mutmut_1': xǁAnthropicProviderǁsupports_images__mutmut_1, 
        'xǁAnthropicProviderǁsupports_images__mutmut_2': xǁAnthropicProviderǁsupports_images__mutmut_2, 
        'xǁAnthropicProviderǁsupports_images__mutmut_3': xǁAnthropicProviderǁsupports_images__mutmut_3
    }
    
    def supports_images(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁAnthropicProviderǁsupports_images__mutmut_orig"), object.__getattribute__(self, "xǁAnthropicProviderǁsupports_images__mutmut_mutants"), args, kwargs, self)
        return result 
    
    supports_images.__signature__ = _mutmut_signature(xǁAnthropicProviderǁsupports_images__mutmut_orig)
    xǁAnthropicProviderǁsupports_images__mutmut_orig.__name__ = 'xǁAnthropicProviderǁsupports_images'
    
    def xǁAnthropicProviderǁsupports_caching__mutmut_orig(self) -> bool:
        """Check if the model supports caching."""
        from ..capabilities import get_model_capabilities
        capabilities = get_model_capabilities(self.model_name)
        return capabilities.supports_caching if capabilities else False
        
    
    def xǁAnthropicProviderǁsupports_caching__mutmut_1(self) -> bool:
        """Check if the model supports caching."""
        from ..capabilities import get_model_capabilities
        capabilities = None
        return capabilities.supports_caching if capabilities else False
        
    
    def xǁAnthropicProviderǁsupports_caching__mutmut_2(self) -> bool:
        """Check if the model supports caching."""
        from ..capabilities import get_model_capabilities
        capabilities = get_model_capabilities(None)
        return capabilities.supports_caching if capabilities else False
        
    
    def xǁAnthropicProviderǁsupports_caching__mutmut_3(self) -> bool:
        """Check if the model supports caching."""
        from ..capabilities import get_model_capabilities
        capabilities = get_model_capabilities(self.model_name)
        return capabilities.supports_caching if capabilities else True
        
    
    xǁAnthropicProviderǁsupports_caching__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁAnthropicProviderǁsupports_caching__mutmut_1': xǁAnthropicProviderǁsupports_caching__mutmut_1, 
        'xǁAnthropicProviderǁsupports_caching__mutmut_2': xǁAnthropicProviderǁsupports_caching__mutmut_2, 
        'xǁAnthropicProviderǁsupports_caching__mutmut_3': xǁAnthropicProviderǁsupports_caching__mutmut_3
    }
    
    def supports_caching(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁAnthropicProviderǁsupports_caching__mutmut_orig"), object.__getattribute__(self, "xǁAnthropicProviderǁsupports_caching__mutmut_mutants"), args, kwargs, self)
        return result 
    
    supports_caching.__signature__ = _mutmut_signature(xǁAnthropicProviderǁsupports_caching__mutmut_orig)
    xǁAnthropicProviderǁsupports_caching__mutmut_orig.__name__ = 'xǁAnthropicProviderǁsupports_caching'
    def xǁAnthropicProviderǁget_max_tokens__mutmut_orig(self) -> Optional[int]:
        """Get the maximum token limit for this model."""
        from ..capabilities import get_model_capabilities
        capabilities = get_model_capabilities(self.model_name)
        return capabilities.output_limit if capabilities else None
        
    def xǁAnthropicProviderǁget_max_tokens__mutmut_1(self) -> Optional[int]:
        """Get the maximum token limit for this model."""
        from ..capabilities import get_model_capabilities
        capabilities = None
        return capabilities.output_limit if capabilities else None
        
    def xǁAnthropicProviderǁget_max_tokens__mutmut_2(self) -> Optional[int]:
        """Get the maximum token limit for this model."""
        from ..capabilities import get_model_capabilities
        capabilities = get_model_capabilities(None)
        return capabilities.output_limit if capabilities else None
        
    
    xǁAnthropicProviderǁget_max_tokens__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁAnthropicProviderǁget_max_tokens__mutmut_1': xǁAnthropicProviderǁget_max_tokens__mutmut_1, 
        'xǁAnthropicProviderǁget_max_tokens__mutmut_2': xǁAnthropicProviderǁget_max_tokens__mutmut_2
    }
    
    def get_max_tokens(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁAnthropicProviderǁget_max_tokens__mutmut_orig"), object.__getattribute__(self, "xǁAnthropicProviderǁget_max_tokens__mutmut_mutants"), args, kwargs, self)
        return result 
    
    get_max_tokens.__signature__ = _mutmut_signature(xǁAnthropicProviderǁget_max_tokens__mutmut_orig)
    xǁAnthropicProviderǁget_max_tokens__mutmut_orig.__name__ = 'xǁAnthropicProviderǁget_max_tokens'
    def xǁAnthropicProviderǁget_context_window__mutmut_orig(self) -> Optional[int]:
        """Get the context window size for this model."""
        from ..capabilities import get_model_capabilities
        capabilities = get_model_capabilities(self.model_name)
        return capabilities.context_limit if capabilities else None
    def xǁAnthropicProviderǁget_context_window__mutmut_1(self) -> Optional[int]:
        """Get the context window size for this model."""
        from ..capabilities import get_model_capabilities
        capabilities = None
        return capabilities.context_limit if capabilities else None
    def xǁAnthropicProviderǁget_context_window__mutmut_2(self) -> Optional[int]:
        """Get the context window size for this model."""
        from ..capabilities import get_model_capabilities
        capabilities = get_model_capabilities(None)
        return capabilities.context_limit if capabilities else None
    
    xǁAnthropicProviderǁget_context_window__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁAnthropicProviderǁget_context_window__mutmut_1': xǁAnthropicProviderǁget_context_window__mutmut_1, 
        'xǁAnthropicProviderǁget_context_window__mutmut_2': xǁAnthropicProviderǁget_context_window__mutmut_2
    }
    
    def get_context_window(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁAnthropicProviderǁget_context_window__mutmut_orig"), object.__getattribute__(self, "xǁAnthropicProviderǁget_context_window__mutmut_mutants"), args, kwargs, self)
        return result 
    
    get_context_window.__signature__ = _mutmut_signature(xǁAnthropicProviderǁget_context_window__mutmut_orig)
    xǁAnthropicProviderǁget_context_window__mutmut_orig.__name__ = 'xǁAnthropicProviderǁget_context_window'